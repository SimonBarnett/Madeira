+ [clubmadeira.io]
+----Wix.py
+----[blueprints]
+----has.py
+----madeira.py
+----[siterequest]
+----sms.py
+----[static]
+------[error]
+------[img]
+------[js]
+------[old]
+--------madeira.py
+----[templates]
+----test.py
+----[utils]
+----wix2.py
+----wixcat.py

+-has.py
def hash_password(plain_password):
    return bcrypt.hashpw(plain_password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')

# Update each user's password
for user_id, settings in users_settings.items():
    plain_password = settings.get("password")
    if plain_password and not plain_password.startswith('$2b$'):  # Check if it's not already a bcrypt hash
        hashed_password = hash_password(plain_password)
        settings["password"] = hashed_password
        print(f"Updated {user_id}: {hashed_password}")

# Save back to users_settings.json
with open('M:/python/Madeira/users_settings.json', 'w') as f:
    json.dump(users_settings, f, indent=4)

print("Passwords updated successfully.")

+-madeira.py
def load_config():
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    return {"jwt": {"SECRET_KEY": "your-secret-key"}}

config = load_config()
app.config['JWT_SECRET_KEY'] = config['jwt']['SECRET_KEY']

# Register blueprints
app.register_blueprint(authentication_bp, url_prefix='')  # Ensure no prefix conflicts
app.register_blueprint(site_request_bp, url_prefix='')
app.register_blueprint(user_management_bp, url_prefix='')
app.register_blueprint(user_settings_bp, url_prefix='')
app.register_blueprint(utility_bp, url_prefix='')
app.register_blueprint(role_pages_bp, url_prefix='')
app.register_blueprint(data_retrieval_bp, url_prefix='')
app.register_blueprint(configuration_bp, url_prefix='')

@app.route('/')
def home():
    return render_template('login.html')

@app.route('/admin')
@login_required(["admin"], require_all=True)
def admin():
    return render_template('admin.html', user_type='admin')  # Pass user_type to template

@app.route('/merchant')
@login_required(["merchant"], require_all=True)
def merchant():
    return render_template('merchant.html')

@app.route('/community')
@login_required(["community"], require_all=True)
def community():
    return render_template('community.html')

@app.route('/wixpro')
@login_required(["wixpro"], require_all=True)
def wixpro():
    return render_template('wixpro.html')

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)

+-sms.py
def send_sms_textmagic(to_number, message):
    try:
        # Your TextMagic credentials
        username = "simonbarnett1"
        api_key = "Nbi5wHksJdtXSlrHCNk9kt7KXnPyjO"
        url = "https://rest.textmagic.com/api/v2/messages"
        
        # Payload with the phone number and message
        payload = {
            "text": message,
            "phones": to_number
        }
        
        # Headers with X-TM-Username and X-TM-Key
        headers = {
            "X-TM-Username": username,
            "X-TM-Key": api_key
        }
        
        # Send the request
        response = requests.post(url, data=payload, headers=headers)
        
        if response.status_code == 201:
            print("Message sent successfully!")
            print(f"Response: {response.json()}")
            return True
        else:
            print(f"Error: {response.status_code} - {response.text}")
            return False
            
    except Exception as e:
        print(f"Error sending SMS: {str(e)}")
        return False

# Test the function
if __name__ == "__main__":
    recipient_number = "+447989389179"
    message_text = "Hello World!"
    send_sms_textmagic(recipient_number, message_text)

+-test.py
def check_domain():
    # Get domain from query parameter
    domain = request.args.get('domain')
    
    # Basic validation (matches client-side regex: /^[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$/)
    if not domain:
        return jsonify({"error": "Please provide a domain name"}), 400
    
    if not all(c.isalnum() or c in '-.' for c in domain) or \
       not '.' in domain or \
       len(domain.split('.')[-1]) < 2:
        return jsonify({"error": "Invalid domain name (e.g., mystore.uk)"}), 400
    
    # Query WHOIS data using python-whois
    try:
        w = whois.whois(domain)
        # If no registration data exists (e.g., creation_date is None), domain is available
        is_available = w.creation_date is None
        return jsonify({
            "domain": domain,
            "available": is_available
        }), 200
    except Exception as e:
        # Handle WHOIS query failures (e.g., timeouts, invalid TLDs)
        return jsonify({"error": f"Failed to check domain availability: {str(e)}"}), 500

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)

+-Wix.py
def fetch_products(limit=100, offset=0, last_numeric_id=None):
    # Base query payload from your earlier request
    query_payload = {
        "query": {},
        "includeVariants": False,
        "includeHiddenProducts": False,
        "includeMerchantSpecificData": False
    }

    # Use limit/offset for smaller datasets
    if last_numeric_id is None:
        query_payload["query"]["paging"] = {"limit": limit, "offset": offset}
    # Use numericId for larger datasets (>10k items)
    else:
        query_payload["query"]["sort"] = [{"numericId": "asc"}]
        query_payload["query"]["filter"] = {"numericId": {"$gt": last_numeric_id}}

    response = requests.post(products_url, headers=headers, json=query_payload)
    if response.status_code != 200:
        print(f"Error fetching products: {response.status_code} - {response.text}")
        return None
    return response.json()

# Step 3: Paginate through products
all_products = []
limit = 100  # Items per page
offset = 0   # Starting point

# First, try limit/offset pagination
while True:
    result = fetch_products(limit=limit, offset=offset)
    if not result or "products" not in result or not result["products"]:
        break  # Stop if no more products

    products = result["products"]
    all_products.extend(products)
    print(f"Fetched {len(products)} products (offset {offset} to {offset + limit - 1})")

    offset += limit
    if len(products) < limit:  # Fewer items than limit means we're done
        break

# If we hit ~10k items or limit/offset fails, switch to numericId
if len(all_products) >= 10000 or not all_products:
    print("Switching to numericId pagination for large datasets...")
    all_products = []  # Reset
    last_numeric_id = None

    while True:
        result = fetch_products(last_numeric_id=last_numeric_id)
        if not result or "products" not in result or not result["products"]:
            break  # Stop if no more products

        products = result["products"]
        all_products.extend(products)
        last_numeric_id = products[-1]["numericId"]  # Get the last numericId
        print(f"Fetched {len(products)} products (numericId > {last_numeric_id})")

# Step 4: Output all fetched products
print(f"\nTotal products fetched: {len(all_products)}")
print(json.dumps(all_products, indent=2))  # Pretty-print all products

+-wix2.py
def get_wix_access_token(client_id):
    """Retrieve an access token for the given Wix clientId."""
    token_url = "https://www.wixapis.com/oauth2/token"
    payload = {
        "clientId": client_id,
        "grantType": "anonymous"
    }
    headers = {"Content-Type": "application/json"}
    try:
        response = requests.post(token_url, json=payload, headers=headers)
        if response.status_code != 200:
            print(f"Error getting token for clientId {client_id}: {response.status_code} - {response.text}")
            return None
        token_data = response.json()
        return token_data["access_token"]
    except Exception as e:
        print(f"Token fetch error for clientId {client_id}: {str(e)}")
        return None
def search_wix_discounted(client_id, collection_id, min_discount_percent=20):
    """Search for discounted Wix products in a collection for a given clientId."""
    access_token = get_wix_access_token(client_id)
    if not access_token:
        return []

    url = "https://www.wixapis.com/stores/v1/products/query"
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {access_token}"
    }
    filter_str = json.dumps({"collections.id": {"$hasSome": [collection_id]}})
    params = {
        "query": {
            "filter": filter_str,
            "paging": {"limit": 100, "offset": 0}  # Higher limit for broader search
        }
    }

    discounted_products = []
    offset = 0
    limit = 100

    try:
        while True:
            params["query"]["paging"]["offset"] = offset
            response = requests.post(url, headers=headers, json=params)
            if response.status_code != 200:
                print(f"Error fetching products for clientId {client_id}, collection {collection_id}: {response.status_code} - {response.text}")
                return discounted_products

            data = response.json()
            products = data.get("products", [])
            if not products:
                break

            for product in products:
                current_price_str = product.get("price", {}).get("formatted", {}).get("price", "0")
                original_price_str = product.get("discountedPrice", {}).get("formatted", {}).get("price", current_price_str)
                
                # Convert prices to floats, removing currency symbols
                try:
                    current_price = float(current_price_str.replace("$", "").replace("£", "").replace(",", ""))
                    original_price = float(original_price_str.replace("$", "").replace("£", "").replace(",", ""))
                except (ValueError, TypeError):
                    continue  # Skip if price conversion fails

                # Check if it’s discounted (original > current)
                if original_price > current_price:
                    discount = ((original_price - current_price) / original_price) * 100
                    if discount >= min_discount_percent:
                        discounted_products.append({
                            "name": product.get("name", ""),
                            "thumbnail": product.get("media", {}).get("mainMedia", {}).get("thumbnail", {}).get("url", ""),
                            "price": current_price_str,
                            "discountPrice": original_price_str,
                            "link": (
                                product.get("productPageUrl", {}).get("base", "").rstrip("/") + "/" +
                                product.get("productPageUrl", {}).get("path", "").lstrip("/")
                            )
                        })

            offset += limit
            if len(products) < limit:  # Fewer items than limit means we're done
                break

        return discounted_products

    except Exception as e:
        print(f"Wix Search Error for clientId {client_id}, collection {collection_id}: {str(e)}")
        return []

# Example usage
if __name__ == "__main__":
    client_id = "9fa0f271-1600-4282-9fae-d841be6aaff6"  # Your Wix clientId
    collection_id = "3357079e-958c-c25e-d594-ea3f72e1660a"  # Example collection (Camping)
    discounted_products = search_wix_discounted(client_id, collection_id, min_discount_percent=20)
    print(json.dumps(discounted_products, indent=2))

+-wixcat.py
def fetch_collections(limit=10, offset=0):
    query_payload = {
        "query": {
            "paging": {"limit": limit, "offset": offset}
        },
        "includeNumberOfProducts": True
    }
    response = requests.post(collections_url, headers=headers, json=query_payload)
    if response.status_code != 200:
        print(f"Error fetching collections: {response.status_code} - {response.text}")
        return None
    return response.json()

# Step 3: Function to fetch products for a collection
products_url = "https://www.wixapis.com/stores/v1/products/query"
def fetch_products_for_collection(collection_id, limit=10, offset=0):
    filter_str = json.dumps({"collections.id": {"$hasSome": [collection_id]}})
    query_payload = {
        "query": {
            "filter": filter_str,
            "paging": {"limit": limit, "offset": offset}
        }
    }
    response = requests.post(products_url, headers=headers, json=query_payload)
    if response.status_code != 200:
        print(f"Error fetching products for collection {collection_id}: {response.status_code} - {response.text}")
        return None
    return response.json()

# Step 4: Fetch all collections and their products
all_collections = []
limit = 10
offset = 0

# Fetch collections
while True:
    result = fetch_collections(limit=limit, offset=offset)
    if not result or "collections" not in result or not result["collections"]:
        break

    collections = result["collections"]
    filtered_collections = [
        {
            "id": col["id"],
            "name": col["name"],
            "numberOfProducts": col["numberOfProducts"],
            "products": []
        }
        for col in collections
        if not col["id"].startswith("00000000")
    ]
    all_collections.extend(filtered_collections)
    print(f"Fetched {len(collections)} collections, kept {len(filtered_collections)} (offset {offset} to {offset + limit - 1})")

    offset += limit
    if len(collections) < limit:
        break

# Fetch products for each collection and filter fields
for collection in all_collections:
    collection_id = collection["id"]
    all_products = []
    offset = 0

    while True:
        result = fetch_products_for_collection(collection_id, limit=limit, offset=offset)
        if not result or "products" not in result or not result["products"]:
            break

        products = result["products"]
        # Filter to only desired fields, combining base and path for link
        filtered_products = [
            {
                "name": product.get("name", ""),
                "thumbnail": product.get("media", {}).get("mainMedia", {}).get("thumbnail", {}).get("url", ""),
                "price": product.get("price", {}).get("formatted", {}).get("price", ""),
                "discountPrice": product.get("discountedPrice", {}).get("formatted", {}).get("price", ""),
                "link": (
                    product.get("productPageUrl", {}).get("base", "") +
                    product.get("productPageUrl", {}).get("path", "")
                )
            }
            for product in products
        ]
        all_products.extend(filtered_products)
        print(f"Fetched {len(products)} products for collection {collection['name']} (offset {offset} to {offset + limit - 1})")

        offset += limit
        if len(products) < limit:
            break

    collection["products"] = all_products
    print(f"Total products in {collection['name']}: {len(all_products)}")

# Step 5: Output the combined data
print(f"\nTotal collections fetched (after filtering): {len(all_collections)}")
print(json.dumps(all_collections, indent=2))  # Pretty-print collections with filtered products

+-blueprints/authentication.py
def login():
    return login_user()

@authentication_bp.route('/signup', methods=['GET'])
def signup_page():
    return render_template('signup.html')

@authentication_bp.route('/signup', methods=['POST'])
def signup():
    # Override signup_user() to ensure correct behavior; replace with signup_user() if it aligns
    data = request.get_json()
    signup_type = data.get('signup_type')
    contact_name = data.get('contact_name')
    signup_phone = data.get('signup_phone')
    signup_email = data.get('signup_email')
    signup_password = data.get('signup_password')

    if not all([signup_type, contact_name, signup_email, signup_password]):
        return jsonify({"status": "error", "message": "Missing required fields"}), 400
    if signup_type in ['seller', 'community'] and not signup_phone:
        return jsonify({"status": "error", "message": "Phone required for Merchant/Community"}), 400

    users_settings = load_users_settings()
    # Check if email already exists
    if any(u['email_address'].lower() == signup_email.lower() for u in users_settings.values()):
        return jsonify({"status": "error", "message": "Email already registered"}), 409

    user_id = f"{int(datetime.datetime.utcnow().timestamp())}{random.randint(1000, 9999)}"  # Unique ID
    hashed_password = bcrypt.hashpw(signup_password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
    
    # Map signup_type to permission
    permission_map = {'seller': 'merchant', 'community': 'community', 'wixpro': 'wixpro'}
    permission = permission_map.get(signup_type, signup_type)

    # Save user without "verified" permission
    users_settings[user_id] = {
        "email_address": signup_email.lower(),
        "contact_name": contact_name,
        "phone_number": signup_phone,  # Consistent with reset-password
        "password": hashed_password,
        "permissions": [permission]  # No "verified" yet
    }
    save_users_settings(users_settings)
    return jsonify({"status": "success", "message": "User created, please verify OTP"}), 201

@authentication_bp.route('/reset-password', methods=['POST'])
def reset_password():
    try:
        data = request.get_json()
        if not data:
            return jsonify({"status": "error", "message": "No data provided"}), 400
        email = data.get("email")
        if not email:
            return jsonify({"status": "error", "message": "Email is required"}), 400

        users_settings = load_users_settings()
        matching_user_id = next((uid for uid, settings in users_settings.items() if settings.get("email_address", "").lower() == email.lower()), None)
        if not matching_user_id:
            return jsonify({"status": "error", "message": "Email not found"}), 404

        user = users_settings[matching_user_id]
        phone_number = user.get("phone_number", "").strip()
        if not phone_number:
            return jsonify({"status": "error", "message": "No phone number associated with this account"}), 400

        otp = ''.join(random.choices(string.digits, k=6))
        reset_expiry = datetime.datetime.utcnow() + datetime.timedelta(minutes=15)
        if "reset_codes" not in current_app.config:
            current_app.config["reset_codes"] = {}
        current_app.config["reset_codes"][matching_user_id] = {"code": otp, "expires": reset_expiry.isoformat()}

        config = load_config()
        textmagic_config = config.get("textmagic", {})
        username = textmagic_config.get("USERNAME")
        api_key = textmagic_config.get("API_KEY")
        if not username or not api_key:
            return jsonify({"status": "error", "message": "TextMagic credentials not configured"}), 500

        url = "https://rest.textmagic.com/api/v2/messages"
        payload = {"text": f"clubmadeira.io one-time password: {otp}. Expires in 15 mins.", "phones": phone_number}
        headers = {"X-TM-Username": username, "X-TM-Key": api_key, "Content-Type": "application/x-www-form-urlencoded"}
        response = requests.post(url, data=payload, headers=headers)

        if response.status_code == 201:
            return jsonify({"status": "success", "message": "A one-time password has been sent to your phone"}), 200
        else:
            return jsonify({"status": "error", "message": f"Failed to send SMS: {response.text}"}), 500
    except Exception as e:
        print(f"Error in reset-password endpoint: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@authentication_bp.route('/verify-reset-code', methods=['POST'])
def verify_reset_code():
    try:
        data = request.get_json(silent=True)
        if not data or not isinstance(data, dict):
            return jsonify({"status": "error", "message": "Invalid or missing JSON data"}), 400
        email = data.get("email")
        code = data.get("code")
        new_password = data.get("new_password")
        if not all([email, code, new_password]):
            return jsonify({"status": "error", "message": "Email, code, and new password are required"}), 400

        users_settings = load_users_settings()
        matching_user_id = next((uid for uid, settings in users_settings.items() if settings.get("email_address", "").lower() == email.lower()), None)
        if not matching_user_id:
            return jsonify({"status": "error", "message": "Email not found"}), 404

        stored_reset = current_app.config.get("reset_codes", {}).get(matching_user_id, {})
        stored_code = stored_reset.get("code")
        if not stored_code:
            return jsonify({"status": "error", "message": "No reset code found for this user"}), 400

        try:
            expiry = datetime.datetime.fromisoformat(stored_reset.get("expires", "2000-01-01T00:00:00"))
        except (ValueError, TypeError) as e:
            print(f"Error parsing expiry: {str(e)}")
            return jsonify({"status": "error", "message": "Invalid reset code expiry format"}), 500

        if stored_code != code or datetime.datetime.utcnow() > expiry:
            return jsonify({"status": "error", "message": "Invalid or expired reset code"}), 400

        user = users_settings[matching_user_id]
        if bcrypt.checkpw(new_password.encode('utf-8'), user["password"].encode('utf-8')):
            # Signup verification: Add "verified" permission
            permissions = user.get("permissions", [])
            if "verified" not in permissions:
                permissions.append("verified")
                user["permissions"] = permissions
        else:
            # Password reset: Update password
            hashed_password = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
            user["password"] = hashed_password

        save_users_settings(users_settings)
        if matching_user_id in current_app.config.get("reset_codes", {}):
            del current_app.config["reset_codes"][matching_user_id]

        # Generate token with updated permissions
        token = generate_token(matching_user_id, user.get("permissions", []))
        return jsonify({"status": "success", "token": token, "user_id": matching_user_id}), 200
    except Exception as e:
        print(f"Unexpected error in verify-reset-code endpoint: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@authentication_bp.route('/update-password', methods=['POST'])
@login_required(["allauth"], require_all=False)
def update_password():
    data = request.get_json()
    if not data or 'email' not in data or 'password' not in data:
        return jsonify({"status": "error", "message": "Email and password required"}), 400
    email = data["email"].strip()
    new_password = data["password"].strip()
    users_settings = load_users_settings()
    user_id = next((uid for uid, u in users_settings.items() if u["email_address"].lower() == email.lower()), None)
    if not user_id or user_id != request.user_id:
        return jsonify({"status": "error", "message": "Unauthorized"}), 403
    hashed_password = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
    users_settings[user_id]["password"] = hashed_password
    save_users_settings(users_settings)
    return jsonify({"status": "success", "message": f"Password updated for {email}", "user_id": user_id}), 200

+-blueprints/configuration.py
def get_config():
    config = load_config() 
    return jsonify({"status": "success", "count": len(config), "config": config}), 200 
 
@configuration_bp.route('/config/<affiliate>', methods=['PATCH']) 
@login_required(["admin"], require_all=True)
def replace_config(affiliate):
    config = load_config() 
    data = request.get_json() 
    if not data or not isinstance(data, dict): 
        return jsonify({"status": "error", "message": "Invalid data"}), 400 
    config[affiliate] = data 
    save_config(config) 
    return jsonify({"status": "success", "message": f"Updated {affiliate} config"}), 200

+-blueprints/data_retrieval.py
def get_categories():
    parent_id = request.args.get('parent_id') 
    categories = get_all_categories(parent_id) 
    return jsonify({"status": "success", "count": len(categories), "categories": categories}), 200 
 
@data_retrieval_bp.route('/discounted-products', methods=['GET'])
def get_all_discounted_products():
    category_id = request.args.get('category_id') 
    if not category_id: 
        return jsonify({"status": "error", "message": "category_id required"}), 400 
    products = search_all_discounted(category_id) 
    return jsonify({"status": "success", "count": len(products), "products": products}), 200

+-blueprints/referral.py
def handle_referral():
    data = request.get_json() 
    if not data or 'timestamp' not in data: 
        return jsonify({"status": "error", "message": "Invalid data"}), 400 
    users_settings = load_users_settings() 
    referer = data.get("referer", "none") 
    if referer not in users_settings: 
        users_settings[referer] = {"referrals": {"visits": [], "orders": []}} 
    if "page" in data: 
        users_settings[referer]["referrals"]["visits"].append({"page": data["page"], "timestamp": data["timestamp"]}) 
    elif "orderId" in data: 
        users_settings[referer]["referrals"]["orders"].append({"orderId": data["orderId"], "buyer": data["buyer"], "total": data["total"], "timestamp": data["timestamp"]}) 
    save_users_settings(users_settings) 
    return jsonify({"status": "success", "message": "Referral recorded", "referer": referer}), 200

+-blueprints/role_pages.py
def load_branding_data():
    try:
        with open(os.path.join(os.path.dirname(__file__), '..', 'branding.json'), 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        # Fallback branding data if the file doesn't exist
        print('load_branding_data - branding.json not found, using fallback data')
        return {
            "admin": "<h1>Admin Dashboard</h1>",
            "merchant": "<h1>Merchant Dashboard</h1>",
            "community": "<h1>Community Dashboard</h1>",
            "wixpro": "<h1>Partner Dashboard</h1>",
            "login": "<h1>Login</h1>",
            "signup": "<h1>Sign Up</h1>"
        }

@role_pages_bp.route('/admin', methods=['GET'])
@login_required(["admin"], require_all=True)
def admin():
    # Get the userId from the request (set by the @login_required decorator)
    user_id = request.user_id
    if not user_id:
        return jsonify({"status": "error", "message": "User ID not found in token"}), 401

    # Load user data
    users_settings = load_users_settings()
    user = users_settings.get(user_id)
    if not user:
        return jsonify({"status": "error", "message": "User not found"}), 404

    # Pass the user object to the template
    return render_template('admin.html', user=user)

@role_pages_bp.route('/community', methods=['GET'])
@login_required(["community", "admin"], require_all=False)
def community():
    user_id = request.user_id
    users_settings = load_users_settings()
    user = users_settings.get(user_id) if user_id else None
    return render_template('community.html', user=user)

@role_pages_bp.route('/merchant', methods=['GET'])
@login_required(["merchant", "admin"], require_all=False)
def merchant():
    user_id = request.user_id
    users_settings = load_users_settings()
    user = users_settings.get(user_id) if user_id else None
    return render_template('merchant.html', user=user)

@role_pages_bp.route('/partner', methods=['GET'])
@login_required(["wixpro", "admin"], require_all=False)
def wixpro():
    user_id = request.user_id
    users_settings = load_users_settings()
    user = users_settings.get(user_id) if user_id else None
    return render_template('partner.html', user=user)

@role_pages_bp.route('/branding', methods=['GET'])
@login_required(["allauth"], require_all=False)
def get_branding():
    print('GET /branding - Request received')
    
    # Get the branding type from the query parameter
    branding_type = request.args.get('type')
    if not branding_type:
        print('GET /branding - No type parameter provided')
        return jsonify({"status": "error", "message": "Branding type not specified"}), 400
    
    print('GET /branding - Requested branding type:', branding_type)

    # Load branding data
    branding_data = load_branding_data()
    
    # Get the branding content for the specified type
    branding = branding_data.get(branding_type, '<h1>Dashboard</h1>')
    
    print('GET /branding - Sending branding content for type:', branding_type, 'Content:', branding)
    return jsonify({
        "status": "success",
        "branding": branding
    }), 200

+-blueprints/site_request.py
def save_site_request_endpoint(user_id):
    try:
        data = request.get_json()
        if not data:
            return jsonify({"status": "error", "message": "No data provided"}), 400

        body_user_id = data.get("userId")
        if body_user_id and body_user_id != user_id:
            return jsonify({"status": "error", "message": "User ID in body does not match URL"}), 400

        if "admin" not in request.permissions and request.user_id != user_id:
            return jsonify({"status": "error", "message": "Unauthorized: Must be admin or match user_id"}), 403

        request_type = data.get("type", "community")
        site_request = {
            "user_id": user_id,
            "type": request_type,
            "communityName": data.get("communityName") or data.get("storeName") or "",
            "aboutCommunity": data.get("aboutCommunity") or data.get("aboutStore") or "",
            "communityLogos": data.get("communityLogos") or data.get("storeLogos") or [],
            "colorPrefs": data.get("colorPrefs", ""),
            "stylingDetails": data.get("stylingDetails", ""),
            "preferredDomain": data.get("preferredDomain", "mycommunity.org"),
            "emails": data.get("emails", []),
            "pages": data.get("pages", []),
            "widgets": data.get("widgets", []),
            "submitted_at": datetime.datetime.utcnow().isoformat()
        }

        if not site_request["communityName"]:
            return jsonify({"status": "error", "message": "Community name or store name is required"}), 400

        domain_regex = r'^[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$'
        if not re.match(domain_regex, site_request["preferredDomain"]):
            return jsonify({"status": "error", "message": "Invalid domain name"}), 400

        for page in site_request["pages"]:
            if "images" in page and page["images"]:
                page["images"] = [img if isinstance(img, str) else "placeholder" for img in page["images"]]

        save_site_request(user_id, site_request)
        return jsonify({"status": "success", "message": "Site request saved successfully"}), 200

    except Exception as e:
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@site_request_bp.route('/siterequests', methods=['GET'])
@login_required(["admin", "wixpro"], require_all=False)
def list_site_requests():
    try:
        siterequest_dir = 'siterequest'
        if not os.path.exists(siterequest_dir):
            return jsonify({"status": "success", "siterequests": []}), 200

        users_settings = load_users_settings()
        siterequests = []

        for filename in os.listdir(siterequest_dir):
            if filename.endswith('.json'):
                user_id = filename.replace('.json', '')
                site_request = load_site_request(user_id)
                if site_request:
                    contact_name = users_settings.get(user_id, {}).get('contact_name', '')
                    email = users_settings.get(user_id, {}).get('email_address', '')
                    request_type = site_request.get('type', '')
                    store_name = site_request.get('storeName')
                    community_name = site_request.get('communityName')
                    organisation = store_name if store_name else community_name if community_name else ''
                    received_at = site_request.get('submitted_at', '')

                    siterequests.append({
                        'user_id': user_id,
                        'type': request_type,
                        'received_at': received_at,
                        'contact_name': contact_name,
                        'email': email,
                        'organisation': organisation
                    })

        siterequests.sort(key=lambda x: x['received_at'] or '', reverse=True)
        return jsonify({"status": "success", "siterequests": siterequests}), 200

    except Exception as e:
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

+-blueprints/user_management.py
def get_users():
    """
    Retrieve a list of all users.
    """
    try:
        users_settings = load_users_settings()
        user_list = [
            {
                "USERid": user_id,
                "email_address": user.get("email_address", ""),
                "contact_name": user.get("contact_name", ""),
                "phone_number": user.get("phone_number", None)  # Add phone_number
            }
            for user_id, user in users_settings.items()
        ]
        return jsonify({"status": "success", "users": user_list}), 200
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

@user_management_bp.route('/users/<user_id>', methods=['GET'])
@login_required(["admin"], require_all=True)
def get_user(user_id):
    """
    Retrieve details of a specific user.
    """
    try:
        users_settings = load_users_settings()
        if user_id not in users_settings:
            return jsonify({"status": "error", "message": "User not found"}), 404
        user = users_settings[user_id]
        user_data = {
            "USERid": user_id,
            "email_address": user.get("email_address", ""),
            "contact_name": user.get("contact_name", ""),
            "phone_number": user.get("phone_number", None),  # Add phone_number
            "permissions": user.get("permissions", []),
            "website_url": user.get("website_url", ""),
            "wixClientId": user.get("wixClientId", ""),
            "referrals": user.get("referrals", {"visits": [], "orders": []})
        }
        return jsonify({"status": "success", "user": user_data}), 200
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

@user_management_bp.route('/permissions/<user_id>', methods=['GET'])
@login_required(["admin"], require_all=True)
def get_permissions(user_id):
    """
    Retrieve the permissions of a specific user.
    """
    try:
        users_settings = load_users_settings()
        if user_id not in users_settings:
            return jsonify({"status": "error", "message": "User not found"}), 404
        permissions = users_settings[user_id].get('permissions', [])
        return jsonify({"status": "success", "permissions": permissions}), 200
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

@user_management_bp.route('/permissions/<user_id>', methods=['POST'])
@login_required(["admin"], require_all=True)
def add_permission(user_id):
    """
    Add a permission to a specific user.
    """
    data = request.get_json()
    if 'permission' not in data:
        return jsonify({"status": "error", "message": "Permission field is required"}), 400
    permission = data['permission']
    try:
        users_settings = load_users_settings()
        if user_id not in users_settings:
            return jsonify({"status": "error", "message": "User not found"}), 404
        if permission in users_settings[user_id].get('permissions', []):
            return jsonify({"status": "error", "message": "Permission already exists"}), 400
        users_settings[user_id]['permissions'].append(permission)
        save_users_settings(users_settings)
        return jsonify({"status": "success", "message": "Permission added"}), 200
    except Exception as e:
        return

+-blueprints/user_settings.py
def get_user_settings(USERid):
    """
    Retrieve the settings for a specific user.
    """
    try:
        users_settings = load_users_settings()
        if USERid not in users_settings:
            return jsonify({"status": "error", "message": "User not found"}), 404
        settings = users_settings[USERid]
        return jsonify({
            "status": "success",
            "contact_name": settings.get("contact_name", ""),
            "website_url": settings.get("website_url", ""),
            "email_address": settings.get("email_address", ""),
            "phone_number": settings.get("phone_number", ""),
            "wixClientId": settings.get("wixClientId", "")
        }), 200
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

@user_settings_bp.route('/<USERid>/user', methods=['PUT'])
@login_required(["self", "admin"], require_all=False)
def put_user_settings(USERid):
    """
    Replace the entire settings for a specific user.
    """
    if not request.json:
        return jsonify({"status": "error", "message": "Request body must contain settings"}), 400
    settings = request.json
    required_fields = ["contact_name", "website_url", "email_address", "phone_number", "wixClientId"]
    if not all(field in settings for field in required_fields):
        return jsonify({"status": "error", "message": "Settings must include all required fields"}), 400
    try:
        users_settings = load_users_settings()
        users_settings[USERid] = settings
        save_users_settings(users_settings)
        return jsonify({
            "status": "success",
            "message": f"Settings for user {USERid} replaced",
            "settings": settings
        }), 200
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

@user_settings_bp.route('/<USERid>/user', methods=['PATCH'])
@login_required(["self", "admin", "wixpro"], require_all=False)
def patch_user_settings(USERid):
    """
    Partially update the settings for a specific user.
    """
    if not request.json:
        return jsonify({"status": "error", "message": "Request body must contain settings"}), 400
    new_settings = request.json
    try:
        users_settings = load_users_settings()
        if USERid not in users_settings:
            return jsonify({"status": "error", "message": "User not found"}), 404
        current_settings = users_settings[USERid]
        valid_fields = ["contact_name", "website_url", "email_address", "phone_number", "wixClientId"]

        # Restrict "wixpro" users to only updating wixClientId unless they have admin or self permissions
        if "wixpro" in request.permissions and not ("admin" in request.permissions or request.user_id == USERid):
            if any(key not in ["wixClientId"] for key in new_settings.keys()):
                return jsonify({"status": "error", "message": "Wixpro can only update wixClientId"}), 403

        # Update only the provided fields
        for key in new_settings:
            if key in valid_fields:
                current_settings[key] = new_settings[key]
        users_settings[USERid] = current_settings
        save_users_settings(users_settings)
        return jsonify({
            "status": "success",
            "message": f"Settings for user {USERid} updated",
            "settings": current_settings
        }), 200
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

+-blueprints/utility.py
def render_md(full_path):
    """
    Render Markdown files from the static folder or GitHub based on the URL path.
    Returns an HTML response using templates from static/error/<status_code>.md.
    """
    from flask import current_app as app
    try:
        # Parse the full_path, removing trailing slashes
        segments = full_path.rstrip('/').split('/')
        if not segments or segments == ['']:
            raise ValueError("Invalid path provided")

        # Determine source: static folder or GitHub
        if segments[0] == 'static':
            # Handle static file
            if len(segments) < 2:
                raise ValueError("No file path provided after 'static'")
            file_path = '/'.join(segments[1:])
            if not file_path.endswith('.md'):
                raise ValueError("Only .md files are supported")
            static_file = os.path.join(app.static_folder, file_path)
            if not os.path.isfile(static_file):
                raise FileNotFoundError("File not found in static folder")
            with open(static_file, 'r', encoding='utf-8') as f:
                md_content = f.read()
        else:
            # Handle GitHub file
            if len(segments) < 4:
                raise ValueError("Invalid GitHub path: Must provide owner/repo/branch/path")
            owner, repo, branch = segments[:3]
            path_segments = segments[3:]
            path = '/'.join(path_segments)
            if not path.endswith('.md'):
                raise ValueError("Only .md files are supported")
            url = f"https://raw.githubusercontent.com/{owner}/{repo}/{branch}/{path}"
            response = requests.get(url)
            if response.status_code != 200:
                raise FileNotFoundError(f"File not found on GitHub: {response.status_code}")
            md_content = response.text

        # Convert Markdown to HTML with table support
        html_content = markdown.markdown(md_content, extensions=['tables'])
        status_code = 200
    except ValueError as e:
        status_code = 404
        error_message = str(e)
    except FileNotFoundError as e:
        status_code = 404
        error_message = str(e)
    except requests.RequestException as e:
        status_code = 500
        error_message = "Failed to fetch from GitHub"
    except Exception as e:
        status_code = 500
        error_message = "An unexpected error occurred"

    # Load the corresponding template
    template_path = os.path.join(app.static_folder, 'error', f'{status_code}.md')
    if not os.path.exists(template_path):
        return jsonify({"status": "error", "message": f"Template for status {status_code} not found"}), 500
    with open(template_path, 'r', encoding='utf-8') as f:
        template = f.read()

    # Replace the appropriate placeholder
    if status_code == 200:
        final_html = template.replace('{content}', html_content)
    else:
        final_html = template.replace('{error_message}', error_message)

    # Create and return the response
    response = make_response(final_html, status_code)
    response.headers['Content-Type'] = 'text/html'
    return response

@utility_bp.route('/check-domain', methods=['GET'])
@login_required(["allauth"], require_all=False)  # Changed from require_permissions
def check_domain():
    """
    Check the availability of a domain name using WHOIS.
    """
    domain = request.args.get('domain')
    
    # Basic validation (matches client-side regex: /^[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$/)
    if not domain:
        return jsonify({"error": "Please provide a domain name"}), 400
    
    if not all(c.isalnum() or c in '-.' for c in domain) or \
       '.' not in domain or \
       len(domain.split('.')[-1]) < 2:
        return jsonify({"error": "Invalid domain name (e.g., mystore.uk)"}), 400
    
    # Query WHOIS data
    try:
        w = whois.whois(domain)
        # If no registration data exists (e.g., creation_date is None), domain is available
        is_available = w.creation_date is None
        return jsonify({
            "domain": domain,
            "available": is_available
        }), 200
    except Exception as e:
        return jsonify({"error": f"Failed to check domain availability: {str(e)}"}), 500

+-static/js/admin-page.js
function initializeAdmin(None) {
    console.log('initializeAdmin - Initializing admin page');
    const token = localStorage.getItem('authToken');
    if (!token) {
        console.error('initializeAdmin - No token found, redirecting to /');
        window.location.href = '/';
        return;
}
function updateUserTable(tableId, users, section) {
    console.log('updateUserTable - Updating table - Table ID:', tableId, 'Section:', section, 'User count:', users.length);
    const tbody = document.getElementById(tableId);
    tbody.innerHTML = '';
    if (users.length === 0) {
        const colspan = 5;
        tbody.innerHTML = `<tr><td colspan="${colspan
}
function createDealRow(product) {
    console.log('createDealRow - Creating deal row - Product:', JSON.stringify(product));
    const tr = document.createElement('tr');
    const discountPercent = product.discount_percent || 
        (product.original_price > product.current_price 
            ? ((product.original_price - product.current_price) / product.original_price * 100).toFixed(2) 
            : 'N/A');
    tr.innerHTML = `
        <td>${product.category || 'N/A'
}
function restoreState(None) {
    console.log('restoreState - Restoring page state (stub)');
}

+-static/js/category-management.js
function createTreeNode(category, level = 0, isAdmin = false, savedCategories = []) {
    console.log('createTreeNode - Creating node - Category:', JSON.stringify(category), 'Level:', level, 'IsAdmin:', isAdmin);
    const li = document.createElement('li');
    const nodeDiv = document.createElement('div');
    nodeDiv.className = 'node';

    const toggle = document.createElement('span');
    toggle.className = 'toggle';
    toggle.setAttribute('data-id', category.id);
    toggle.textContent = '+'; // Default to '+' assuming subcategories may exist
    toggle.addEventListener('click', () => toggleSubcategories(category.id, toggle));

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = category.id;
    if (isAdmin) {
        checkbox.addEventListener('change', () => handleCategorySelection(category.id, checkbox));
}
function createTreeNode(category, level = 0, isAdmin = false, savedCategories = []) {
    console.log('createTreeNode - Creating node - Category:', JSON.stringify(category), 'Level:', level, 'IsAdmin:', isAdmin);
    const li = document.createElement('li');
    const nodeDiv = document.createElement('div');
    nodeDiv.className = 'node';

    const toggle = document.createElement('span');
    toggle.className = 'toggle';
    toggle.setAttribute('data-id', category.id);
    toggle.textContent = '+'; // Default to '+' assuming subcategories may exist
    toggle.addEventListener('click', () => toggleSubcategories(category.id, toggle));

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = category.id;
    if (isAdmin) {
        checkbox.addEventListener('change', () => handleCategorySelection(category.id, checkbox));
}

+-static/js/common.js
function setupToastr(None) {
    console.log('setupToastr - Initiating Toastr configuration');
    toastr.options = {
        closeButton: true,
        progressBar: true,
        positionClass: 'toast-top-right',
        timeOut: 5000,
        showMethod: 'slideDown',
        hideMethod: 'slideUp'
}

+-static/js/community-page.js
function initializeCommunity(None) {
    console.log('initializeCommunity - Initializing community page');
    const token = localStorage.getItem('authToken');
    const userId = localStorage.getItem('userId');
    if (!token) {
        console.error('initializeCommunity - No token found, redirecting to /');
        window.location.href = '/';
        return;
}
function updateMenu(None) {
    console.log('updateMenu - Updating menu');
    const menu = document.getElementById('menu');
    const userId = document.getElementById('userId').value;
    menu.innerHTML = `<input type="text" id="userId" style="display: none;" value="${userId || ''
}
function updateIntegrationCode(section) {
    console.log('updateIntegrationCode - Updating integration code - Section:', section);
    const codeElements = {
        'wix': 'wixCode',
        'wordpress': 'wordpressCode',
        'squarespace': 'squarespaceCode',
        'weebly': 'weeblyCode',
        'joomla': 'joomlaCode'
}
function updateVisitsTable(tableId, visits) {
    console.log('updateVisitsTable - Updating table - Table ID:', tableId, 'Visits:', visits.length);
    const tbody = document.getElementById(tableId);
    if (tbody) {
        tbody.innerHTML = visits.length === 0 ? '<tr><td colspan="2">No visits found</td></tr>' : '';
        visits.forEach(visit => {
            const row = document.createElement('tr');
            row.innerHTML = `<td>${visit.page
}
function updateOrdersTable(tableId, orders) {
    console.log('updateOrdersTable - Updating table - Table ID:', tableId, 'Orders:', orders.length);
    const tbody = document.getElementById(tableId);
    if (tbody) {
        tbody.innerHTML = orders.length === 0 ? '<tr><td colspan="4">No orders found</td></tr>' : '';
        orders.forEach(order => {
            const row = document.createElement('tr');
            row.innerHTML = `<td>${order.orderId
}
function waitForTinyMCE(callback) {
    console.log('waitForTinyMCE - Checking if TinyMCE is loaded');
    if (typeof tinymce !== 'undefined' && tinymce.init) {
        console.log('waitForTinyMCE - TinyMCE is loaded, executing callback');
        callback();
}

+-static/js/merchant-page.js
function initializeMerchant(None) {
    console.log('initializeMerchant - Initializing merchant page');
    const token = localStorage.getItem('authToken');
    const userId = localStorage.getItem('userId');
    if (!token) {
        console.error('initializeMerchant - No token found, redirecting to /');
        window.location.href = '/';
        return;
}
function checkAdminPermission(None) {
    console.log('checkAdminPermission - Checking admin permission');
    const backButton = document.querySelector('button[data-href="/admin"]');
    if (backButton) {
        backButton.style.display = window.userPermissions.includes('admin') ? 'block' : 'none';
        console.log('checkAdminPermission - Back button visibility:', backButton.style.display);
}
function createProductRow(product) {
    console.log('createProductRow - Creating row - Product:', JSON.stringify(product));
    const tr = document.createElement('tr');
    tr.innerHTML = `
        <td class="hidden">${product.id
}

+-static/js/page-load.js
function showLoadingOverlay(None) {
    let loadingOverlay = document.getElementById('loadingOverlay');
    if (!loadingOverlay) {
        loadingOverlay = document.createElement('div');
        loadingOverlay.id = 'loadingOverlay';
        loadingOverlay.innerHTML = `
            <div class="multicircle-loader">
                <div class="circle circle1"></div>
                <div class="circle circle2"></div>
                <div class="circle circle3"></div>
                <div class="circle circle4"></div>
            </div>
        `;
        document.body.prepend(loadingOverlay);
        console.log('showLoadingOverlay - Created and prepended loading overlay');
}
function attachEventListeners(None) {
    console.log('attachEventListeners - Attaching event listeners');
    const buttons = document.querySelectorAll('button[data-section], button[data-submenu], button[data-href]');
    console.log('attachEventListeners - Found buttons with data attributes:', buttons.length);
    buttons.forEach(button => {
        if (button.dataset.section || button.dataset.submenu) {
            button.addEventListener('click', handleSectionClick);
            console.log('attachEventListeners - Added click listener to button with data-section/submenu:', button.dataset.section || button.dataset.submenu);
}
function initializePage(requiredPermissions, callback) {
    console.log('initializePage - Starting initialization - Permissions required:', requiredPermissions);
    const token = localStorage.getItem('authToken');
    console.log('initializePage - Retrieved token from localStorage:', token || 'None');
    if (!token) {
        console.warn('initializePage - No auth token found - Redirecting to /');
        window.location.href = '/';
        return;
}
function handleSectionClick(event) {
    console.log('handleSectionClick - Section click event triggered');
    const target = event.target.closest('button[data-section], button[data-submenu]');
    console.log('handleSectionClick - Event target:', target);
    if (!target) return;

    event.stopPropagation(); // Stop bubbling to parent elements

    const sectionId = target.getAttribute('data-section');
    const submenuId = target.getAttribute('data-submenu');
    console.log(`handleSectionClick - Extracted attributes - Section: ${sectionId
}

+-static/js/partner-page.js
function initializePartner(None) {
    console.log('initializePartner - Initializing partner page');
    const token = localStorage.getItem('authToken');
    const userId = localStorage.getItem('userId');
    if (!token) {
        console.error('initializePartner - No token found, redirecting to /');
        window.location.href = '/';
        return;
}
function checkAdminPermission(None) {
    console.log('checkAdminPermission - Checking admin permission');
    const backButton = document.querySelector('button[data-href="/admin"]');
    if (backButton) {
        backButton.style.display = window.userPermissions.includes('admin') ? 'block' : 'none';
        console.log('checkAdminPermission - Back button visibility:', backButton.style.display);
}

+-static/js/site-auth.js
function togglePassword(fieldId) {
    console.log('togglePassword - Initiating visibility toggle - Field ID:', fieldId);
    const input = document.getElementById(fieldId);
    const icon = input ? input.nextElementSibling : null;
    console.log('togglePassword - Input element retrieved:', input, 'Icon element:', icon);

    if (!input) {
        console.error('togglePassword - Password input not found - Field ID:', fieldId);
        return;
}
function logOff(None) {
    console.log('logOff - Initiating logout process');
    const confirmed = confirm('Are you sure you want to log off?');
    console.log('logOff - User confirmation received:', confirmed);

    if (confirmed) {
        console.log('logOff - User confirmed logout - Clearing session data');
        localStorage.removeItem('authToken');
        localStorage.removeItem('userId');
        console.log('logOff - Auth token and userId removed from localStorage - Current localStorage:', JSON.stringify(localStorage));
        toastr.success('Logged off successfully');
        console.log('logOff - Success toast displayed');

        setTimeout(() => {
            console.log('logOff - Redirecting to / after 1-second delay');
            window.location.href = '/';
            console.log('logOff - Redirect executed');
}
function decodeJWT(token) {
    console.log('decodeJWT - Starting JWT decoding - Input token:', token);
    if (!token || typeof token !== 'string') {
        console.warn('decodeJWT - Invalid token: null or not a string - Token:', token);
        return null;
}

+-static/js/site-navigation.js
function showSection(sectionId, onSectionLoad = null) {
    console.log('showSection - Starting section display - Section ID:', sectionId);
    console.log('showSection - Callback provided:', typeof onSectionLoad === 'function' ? 'Yes' : 'No');
    const allSections = document.querySelectorAll('.section');
    console.log('showSection - Found sections to hide:', allSections.length);
    allSections.forEach(s => {
        console.log('showSection - Hiding section - ID:', s.id);
        s.classList.remove('active');
        s.style.display = 'none';
}
function toggleSubmenu(submenuId) {
    console.log(`toggleSubmenu - Starting toggle - Submenu ID: ${submenuId
}
function initializeNavigation(None) {
    console.log('initializeNavigation - Starting navigation setup');

    // Initialize submenu states (all closed by default)
    document.querySelectorAll('.submenu').forEach(submenu => {
        submenu.style.display = 'none';
        submenu.classList.remove('open');
        const submenuId = submenu.id;
        const button = document.querySelector(`button[data-submenu="${submenuId
}

+-static/js/site-request.js
function addPage(type = 'merchant') {
    console.log('addPage - Adding page to site request - Type:', type);
    const maxPages = 5;
    let pageCount = parseInt(localStorage.getItem(`${type
}
function removePage(pageNum, type = 'merchant') {
    console.log('removePage - Removing page - Page number:', pageNum, 'Type:', type);
    let pageCount = parseInt(localStorage.getItem(`${type
}
function addEmail(type = 'merchant') {
    console.log('addEmail - Adding email to site request - Type:', type);
    const maxEmails = 5;
    let emailCount = parseInt(localStorage.getItem(`${type
}
function removeEmail(emailNum, type = 'merchant') {
    console.log('removeEmail - Removing email - Email number:', emailNum, 'Type:', type);
    let emailCount = parseInt(localStorage.getItem(`${type
}
function updateDomainPreview(type = 'merchant') {
    console.log('updateDomainPreview - Updating domain preview - Type:', type);
    const domain = document.getElementById('preferredDomain')?.value || (type === 'merchant' ? 'mystore.uk' : 'mycommunity.org');
    console.log('updateDomainPreview - Domain value:', domain);

    const previewElement = document.getElementById('domainPreview');
    if (previewElement) {
        previewElement.textContent = `@${domain
}
function initializeTinyMCE(selector = 'textarea[name$="Content"], #aboutStore, #aboutCommunity') {
    console.log('initializeTinyMCE - Starting TinyMCE initialization - Selector:', selector);
    if (!window.tinymce) {
        console.error('initializeTinyMCE - TinyMCE not available');
        return;
}
function getCurrentTimestamp(None) {
    console.log('getCurrentTimestamp - Generating current timestamp');
    const now = new Date();
    console.log('getCurrentTimestamp - Current date object:', now);
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    console.log('getCurrentTimestamp - Extracted components - Year:', year, 'Month:', month, 'Day:', day, 'Hours:', hours, 'Minutes:', minutes, 'Seconds:', seconds);
    const timestamp = `${year
}

+-static/old/all.js
function initializeAdmin(None) {
    console.log('initializeAdmin - Initializing admin page');
    const token = localStorage.getItem('authToken');
    if (!token) {
        console.error('initializeAdmin - No token found, redirecting to /');
        window.location.href = '/';
        return;
}
function updateUserTable(tableId, users, section) {
    console.log('updateUserTable - Updating table - Table ID:', tableId, 'Section:', section, 'User count:', users.length);
    const tbody = document.getElementById(tableId);
    tbody.innerHTML = '';
    if (users.length === 0) {
        const colspan = section === 'communities' ? 3 : 4;
        tbody.innerHTML = `<tr><td colspan="${colspan
}
function createDealRow(product) {
    console.log('createDealRow - Creating deal row - Product:', JSON.stringify(product));
    const tr = document.createElement('tr');
    const discountPercent = product.discount_percent || 
        (product.original_price > product.current_price 
            ? ((product.original_price - product.current_price) / product.original_price * 100).toFixed(2) 
            : 'N/A');
    tr.innerHTML = `
        <td>${product.category || 'N/A'
}
function createTreeNode(category, level = 0, isAdmin = false, savedCategories = []) {
    console.log('createTreeNode - Creating node - Category:', JSON.stringify(category), 'Level:', level, 'IsAdmin:', isAdmin);
    const li = document.createElement('li');
    const nodeDiv = document.createElement('div');
    nodeDiv.className = 'node';

    const toggle = document.createElement('span');
    toggle.className = 'toggle';
    toggle.setAttribute('data-id', category.id);
    toggle.textContent = '+'; // Default to '+' assuming subcategories may exist
    toggle.addEventListener('click', () => toggleSubcategories(category.id, toggle));

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = category.id;
    if (isAdmin) {
        checkbox.addEventListener('change', () => handleCategorySelection(category.id, checkbox));
}
function createTreeNode(category, level = 0, isAdmin = false, savedCategories = []) {
    console.log('createTreeNode - Creating node - Category:', JSON.stringify(category), 'Level:', level, 'IsAdmin:', isAdmin);
    const li = document.createElement('li');
    const nodeDiv = document.createElement('div');
    nodeDiv.className = 'node';

    const toggle = document.createElement('span');
    toggle.className = 'toggle';
    toggle.setAttribute('data-id', category.id);
    toggle.textContent = '+'; // Default to '+' assuming subcategories may exist
    toggle.addEventListener('click', () => toggleSubcategories(category.id, toggle));

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = category.id;
    if (isAdmin) {
        checkbox.addEventListener('change', () => handleCategorySelection(category.id, checkbox));
}
function setupToastr(None) {
    console.log('setupToastr - Initiating Toastr configuration');
    toastr.options = {
        closeButton: true,
        progressBar: true,
        positionClass: 'toast-top-right',
        timeOut: 5000,
        showMethod: 'slideDown',
        hideMethod: 'slideUp'
}
function initializeCommunity(None) {
    console.log('initializeCommunity - Initializing community page');
    const token = localStorage.getItem('authToken');
    const userId = localStorage.getItem('userId');
    if (!token) {
        console.error('initializeCommunity - No token found, redirecting to /');
        window.location.href = '/';
        return;
}
function updateMenu(None) {
    console.log('updateMenu - Updating menu');
    const menu = document.getElementById('menu');
    const userId = document.getElementById('userId').value;
    menu.innerHTML = `<input type="text" id="userId" style="display: none;" value="${userId || ''
}
function updateIntegrationCode(section) {
    console.log('updateIntegrationCode - Updating integration code - Section:', section);
    const codeElements = {
        'wix': 'wixCode',
        'wordpress': 'wordpressCode',
        'squarespace': 'squarespaceCode',
        'weebly': 'weeblyCode',
        'joomla': 'joomlaCode'
}
function updateVisitsTable(tableId, visits) {
    console.log('updateVisitsTable - Updating table - Table ID:', tableId, 'Visits:', visits.length);
    const tbody = document.getElementById(tableId);
    if (tbody) {
        tbody.innerHTML = visits.length === 0 ? '<tr><td colspan="2">No visits found</td></tr>' : '';
        visits.forEach(visit => {
            const row = document.createElement('tr');
            row.innerHTML = `<td>${visit.page
}
function updateOrdersTable(tableId, orders) {
    console.log('updateOrdersTable - Updating table - Table ID:', tableId, 'Orders:', orders.length);
    const tbody = document.getElementById(tableId);
    if (tbody) {
        tbody.innerHTML = orders.length === 0 ? '<tr><td colspan="4">No orders found</td></tr>' : '';
        orders.forEach(order => {
            const row = document.createElement('tr');
            row.innerHTML = `<td>${order.orderId
}
function waitForTinyMCE(callback) {
    console.log('waitForTinyMCE - Checking if TinyMCE is loaded');
    if (typeof tinymce !== 'undefined' && tinymce.init) {
        console.log('waitForTinyMCE - TinyMCE is loaded, executing callback');
        callback();
}
function initializeMerchant(None) {
    console.log('initializeMerchant - Initializing merchant page');
    const token = localStorage.getItem('authToken');
    const userId = localStorage.getItem('userId');
    if (!token) {
        console.error('initializeMerchant - No token found, redirecting to /');
        window.location.href = '/';
        return;
}
function checkAdminPermission(None) {
    console.log('checkAdminPermission - Checking admin permission');
    const backButton = document.querySelector('button[data-href="/admin"]');
    if (backButton) {
        backButton.style.display = window.userPermissions.includes('admin') ? 'block' : 'none';
        console.log('checkAdminPermission - Back button visibility:', backButton.style.display);
}
function createProductRow(product) {
    console.log('createProductRow - Creating row - Product:', JSON.stringify(product));
    const tr = document.createElement('tr');
    tr.innerHTML = `
        <td class="hidden">${product.id
}
function initializePage(permissionRequired, callback) {
    console.log('initializePage - Starting initialization - Permission required:', permissionRequired);
    const token = localStorage.getItem('authToken');
    console.log('initializePage - Retrieved token from localStorage:', token || 'None');
    if (!token) {
        console.warn('initializePage - No auth token found - Redirecting to /');
        window.location.href = '/';
        return;
}
function initialize(pageType) {
    console.log('initialize - Starting page initialization - Page type:', pageType);
    
    const pageConfigs = {
        'partner': {
            permission: 'admin',
            brandingType: 'partner',
            initialSection: null,
            requiresUserId: false,
            extraSteps: () => {
                console.log('initialize - Executing partner-specific steps');
                attachEventListeners();
                console.log('initialize - Partner-specific steps completed');
}
function performPageSetup(pageType, config) {
    console.log('performPageSetup - Starting setup - Page type:', pageType);
    
    console.log('performPageSetup - Loading branding - Type:', config.brandingType);
    loadBranding(config.brandingType); // From site-navigation.js

    if (config.initialSection) {
        console.log('performPageSetup - Showing initial section - ID:', config.initialSection);
        showSection(config.initialSection); // From site-navigation.js
}
function handleSectionClick(event) {
    console.log('handleSectionClick - Section click event triggered');
    const target = event.currentTarget;
    console.log('handleSectionClick - Event target:', target);
    const section = target.getAttribute('data-section');
    const submenu = target.getAttribute('data-submenu');
    console.log('handleSectionClick - Extracted attributes - Section:', section, 'Submenu:', submenu);
    if (submenu) {
        console.log('handleSectionClick - Toggling submenu - ID:', submenu);
        toggleSubmenu(submenu); // From site-navigation.js
}
function initializePartner(None) {
    console.log('initializePartner - Initializing partner page');
    const token = localStorage.getItem('authToken');
    const userId = localStorage.getItem('userId');
    if (!token) {
        console.error('initializePartner - No token found, redirecting to /');
        window.location.href = '/';
        return;
}
function checkAdminPermission(None) {
    console.log('checkAdminPermission - Checking admin permission');
    const backButton = document.querySelector('button[data-href="/admin"]');
    if (backButton) {
        backButton.style.display = window.userPermissions.includes('admin') ? 'block' : 'none';
        console.log('checkAdminPermission - Back button visibility:', backButton.style.display);
}
function togglePassword(fieldId) {
    console.log('togglePassword - Initiating visibility toggle - Field ID:', fieldId);
    const input = document.getElementById(fieldId);
    const icon = input ? input.nextElementSibling : null;
    console.log('togglePassword - Input element retrieved:', input, 'Icon element:', icon);

    if (!input) {
        console.error('togglePassword - Password input not found - Field ID:', fieldId);
        return;
}
function logOff(None) {
    console.log('logOff - Initiating logout process');
    const confirmed = confirm('Are you sure you want to log off?');
    console.log('logOff - User confirmation received:', confirmed);

    if (confirmed) {
        console.log('logOff - User confirmed logout - Clearing session data');
        localStorage.removeItem('authToken');
        localStorage.removeItem('userId');
        console.log('logOff - Auth token and userId removed from localStorage - Current localStorage:', JSON.stringify(localStorage));
        toastr.success('Logged off successfully');
        console.log('logOff - Success toast displayed');

        setTimeout(() => {
            console.log('logOff - Redirecting to / after 1-second delay');
            window.location.href = '/';
            console.log('logOff - Redirect executed');
}
function decodeJWT(token) {
    console.log('decodeJWT - Starting JWT decoding - Input token:', token);
    if (!token || typeof token !== 'string') {
        console.warn('decodeJWT - Invalid token: null or not a string - Token:', token);
        return null;
}
function showSection(sectionId, onSectionLoad = null) {
    console.log('showSection - Starting section display - Section ID:', sectionId);
    console.log('showSection - Callback provided:', typeof onSectionLoad === 'function' ? 'Yes' : 'No');
    const allSections = document.querySelectorAll('.section');
    console.log('showSection - Found sections to hide:', allSections.length);
    allSections.forEach(s => {
        console.log('showSection - Hiding section - ID:', s.id);
        s.classList.remove('active');
        s.style.display = 'none';
}
function toggleSubmenu(submenuId) {
    console.log('toggleSubmenu - Starting toggle - Submenu ID:', submenuId);
    const submenu = document.getElementById(submenuId);
    console.log('toggleSubmenu - Submenu element retrieved:', submenu);
    if (!submenu) {
        console.warn('toggleSubmenu - Submenu element not found - ID:', submenuId);
        return;
}
function addPage(type = 'merchant') {
    console.log('addPage - Adding page to site request - Type:', type);
    const maxPages = 5;
    let pageCount = parseInt(localStorage.getItem(`${type
}
function removePage(pageNum, type = 'merchant') {
    console.log('removePage - Removing page - Page number:', pageNum, 'Type:', type);
    let pageCount = parseInt(localStorage.getItem(`${type
}
function addEmail(type = 'merchant') {
    console.log('addEmail - Adding email to site request - Type:', type);
    const maxEmails = 5;
    let emailCount = parseInt(localStorage.getItem(`${type
}
function removeEmail(emailNum, type = 'merchant') {
    console.log('removeEmail - Removing email - Email number:', emailNum, 'Type:', type);
    let emailCount = parseInt(localStorage.getItem(`${type
}
function updateDomainPreview(type = 'merchant') {
    console.log('updateDomainPreview - Updating domain preview - Type:', type);
    const domain = document.getElementById('preferredDomain')?.value || (type === 'merchant' ? 'mystore.uk' : 'mycommunity.org');
    console.log('updateDomainPreview - Domain value:', domain);

    const previewElement = document.getElementById('domainPreview');
    if (previewElement) {
        previewElement.textContent = `@${domain
}
function initializeTinyMCE(selector = 'textarea[name$="Content"], #aboutStore, #aboutCommunity') {
    console.log('initializeTinyMCE - Starting TinyMCE initialization - Selector:', selector);
    if (!window.tinymce) {
        console.error('initializeTinyMCE - TinyMCE not available');
        return;
}
function getCurrentTimestamp(None) {
    console.log('getCurrentTimestamp - Generating current timestamp');
    const now = new Date();
    console.log('getCurrentTimestamp - Current date object:', now);
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    console.log('getCurrentTimestamp - Extracted components - Year:', year, 'Month:', month, 'Day:', day, 'Hours:', hours, 'Minutes:', minutes, 'Seconds:', seconds);
    const timestamp = `${year
}

+-static/old/madeira.py
def load_config():
    
def require_permissions(required_permissions, require_all=True):
    
def decorator(f):
    @wraps(f)
def decorated_function(*args, **kwargs):
    auth_header = request.headers.get("Authorization")
            if not auth_header or not auth_header.startswith("Bearer "):
                return jsonify({"status": "error", "message": "Authorization token required"}), 401
            
            token = auth_header.split(" ")[1]
            try:
                payload = jwt.decode(token, app.config['JWT_SECRET_KEY'] , algorithms=["HS256"])
                if datetime.datetime.utcnow().timestamp() > payload["exp"]:
                    return jsonify({"status": "error", "message": "Token has expired"}), 401
                user_permissions = payload.get("permissions", [])
                request.user_id = payload["userId"]
                request.permissions = user_permissions
            except jwt.InvalidTokenError:
                return jsonify({"status": "error", "message": "Invalid token"}), 401
            except Exception as e:
                return jsonify({"status": "error", "message": f"Token error: {str(e)}"}), 500

            # Handle shorthands
            effective_perms = []
            for perm in required_permissions:
                if perm == "allauth":
                    effective_perms.extend(["admin", "merchant", "community", "wixpro"])
                elif perm == "self":
                    user_id_in_route = next((v for v in kwargs.values() if isinstance(v, str)), None)
                    if user_id_in_route and request.user_id != user_id_in_route:
                        effective_perms.append(None)  # Fails unless other perms allow
                    elif not user_id_in_route:  # For endpoints like /update-password
                        effective_perms.append("self")  # Check in function
                else:
                    effective_perms.append(perm)

            # Permission check
            if require_all:
                if not all(perm in user_permissions for perm in effective_perms if perm is not None and perm != "self"):
                    return jsonify({"status": "error", "message": f"Insufficient permissions: {effective_perms}"}), 403
            else:
                if not any(perm in user_permissions for perm in effective_perms if perm is not None and perm != "self"):
                    return jsonify({"status": "error", "message": f"Insufficient permissions: {effective_perms}"}), 403

            return f(*args, **kwargs)
        return decorated_function
    return decorator

# region Helper Functions
def generate_code():
    charset = string.digits + string.ascii_uppercase
    code = ''.join(random.choice(charset) for _ in range(7))
    total = sum(charset.index(c) for c in code)
    checksum = charset[total % 36]
    return code + checksum
def load_users_categories():
    if os.path.exists(USERS_FILE):
        try:
            with open(USERS_FILE, 'r') as f:
                return json.load(f)
        except Exception as e:
            print(f"Error loading {USERS_FILE}: {str(e)}")
            return {}
    return {}
def save_users_categories(users_data):
    try:
        with open(USERS_FILE, 'w') as f:
            json.dump(users_data, f, indent=4)
    except Exception as e:
        print(f"Error saving {USERS_FILE}: {str(e)}")
def get_user_categories(user_id):
    users_data = load_users_categories()
    if user_id not in users_data:
        users_data[user_id] = DEFAULT_CATEGORIES
        save_users_categories(users_data)
    return users_data.get(user_id, [])
def load_users_products():
    users_settings = load_users_settings()
    users_products = {}
    
    for user_id, settings in users_settings.items():
        wix_client_id = settings.get("wixClientId")
        if not wix_client_id:
            print(f"No wixClientId found for user {user_id}")
            users_products[user_id] = []
            continue

        token_url = "https://www.wixapis.com/oauth2/token"
        payload = {"clientId": wix_client_id, "grantType": "anonymous"}
        headers = {"Content-Type": "application/json"}
        try:
            response = requests.post(token_url, json=payload, headers=headers)
            if response.status_code != 200:
                print(f"Error getting token for user {user_id}: {response.status_code} - {response.text}")
                users_products[user_id] = []
                continue
            token_data = response.json()
            access_token = token_data["access_token"]
            print(f"Access Token for user {user_id}: {access_token}")
        except Exception as e:
            print(f"Token fetch error for user {user_id}: {str(e)}")
            users_products[user_id] = []
            continue

        collections_url = "https://www.wixapis.com/stores-reader/v1/collections/query"
        headers = {"Content-Type": "application/json", "Authorization": f"Bearer {access_token}"}
def fetch_collections(limit=10, offset=0):
    query_payload = {"query": {"paging": {"limit": limit, "offset": offset}}, "includeNumberOfProducts": True}
            response = requests.post(collections_url, headers=headers, json=query_payload)
            if response.status_code != 200:
                print(f"Error fetching collections for user {user_id}: {response.status_code} - {response.text}")
                return None
            return response.json()

        products_url = "https://www.wixapis.com/stores/v1/products/query"
def fetch_products_for_collection(collection_id, limit=10, offset=0):
    filter_str = json.dumps({"collections.id": {"$hasSome": [collection_id]}})
            query_payload = {"query": {"filter": filter_str, "paging": {"limit": limit, "offset": offset}}}
            response = requests.post(products_url, headers=headers, json=query_payload)
            if response.status_code != 200:
                print(f"Error fetching products for collection {collection_id} for user {user_id}: {response.status_code} - {response.text}")
                return None
            return response.json()

        all_collections = []
        limit = 10
        offset = 0

        while True:
            result = fetch_collections(limit=limit, offset=offset)
            if not result or "collections" not in result or not result["collections"]:
                break

            collections = result["collections"]
            filtered_collections = [{"id": col["id"], "name": col["name"], "numberOfProducts": col["numberOfProducts"], "products": []} 
                                    for col in collections if not col["id"].startswith("00000000")]
            all_collections.extend(filtered_collections)
            print(f"Fetched {len(collections)} collections, kept {len(filtered_collections)} for user {user_id} (offset {offset} to {offset + limit - 1})")
            offset += limit
            if len(collections) < limit:
                break

        all_products = []
        for collection in all_collections:
            collection_id = collection["id"]
            collection_name = collection["name"]
            offset = 0

            while True:
                result = fetch_products_for_collection(collection_id, limit=limit, offset=offset)
                if not result or "products" not in result or not result["products"]:
                    break

                products = result["products"]
                for product in products:
                    current_price = float(product.get("price", {}).get("formatted", {}).get("price", "0").replace("$", "").replace("£", "").replace(",", "") or 0.0)
                    original_price = float(product.get("discountedPrice", {}).get("formatted", {}).get("price", str(current_price)).replace("$", "").replace("£", "").replace(",", "") or current_price)
                    discount = ((original_price - current_price) / original_price) * 100 if original_price > current_price else 0
                    base_url = product.get("productPageUrl", {}).get("base", "").rstrip("/") + "/" + product.get("productPageUrl", {}).get("path", "").lstrip("/")
                    product_url = f"{base_url}?referer={user_id}"
                    all_products.append({
                        "source": user_id,
                        "id": product.get("id", ""),
                        "title": product.get("name", ""),
                        "product_url": product_url,
                        "current_price": current_price,
                        "original_price": original_price,
                        "discount_percent": round(discount, 2),
                        "image_url": product.get("media", {}).get("mainMedia", {}).get("thumbnail", {}).get("url", ""),
                        "qty": int(product.get("stock", {}).get("quantity", 0)) if product.get("stock", {}).get("trackQuantity", False) else -1,
                        "category": collection_name,
                        "user_id": user_id
                    })
                print(f"Fetched {len(products)} products for collection {collection_name} for user {user_id} (offset {offset} to {offset + limit - 1})")
                offset += limit
                if len(products) < limit:
                    break

        users_products[user_id] = all_products
        print(f"Total products fetched for user {user_id}: {len(all_products)}")

    return users_products
def save_users_products(users_products):
    with open(USERS_PRODUCTS_FILE, 'w') as f:
        json.dump(users_products, f, indent=4)
def get_user_products(user_id):
    users_products = load_users_products()
    return users_products.get(user_id, [])
def save_config(config):
    try:
        if not isinstance(config, dict):
            raise ValueError("Config must be a dictionary")
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=4)
        print(f"Config saved successfully to {CONFIG_FILE}")
    except IOError as e:
        print(f"Error saving {CONFIG_FILE}: {str(e)}")
        raise
    except ValueError as e:
        print(f"Error: {str(e)}")
        raise
    except Exception as e:
        print(f"Unexpected error saving {CONFIG_FILE}: {str(e)}")
        raise
def get_amazon_category_title(browse_node_id):
    config = load_config()
    if all(config.get("amazon_uk", {}).values()):
        amazon = AmazonApi(config["amazon_uk"]["ACCESS_KEY"], config["amazon_uk"]["SECRET_KEY"],
                           config["amazon_uk"]["ASSOCIATE_TAG"], config["amazon_uk"]["COUNTRY"])
        try:
            browse_nodes = amazon.get_browse_nodes(browse_node_ids=[browse_node_id], resources=["BrowseNodes.DisplayName"])
            if browse_nodes and browse_nodes.browse_nodes:
                return browse_nodes.browse_nodes[0].display_name
        except Exception as e:
            print(f"Error fetching category title for {browse_node_id}: {str(e)}")
def find_category_recursive(categories, target_id):
    for category in categories:
            if category.get("id") == target_id:
                return category.get("name")
            if "subcategories" in category:
                result = find_category_recursive(category["subcategories"], target_id)
                if result is not None:
                    return result
    return find_category_recursive(PSEUDO_CATEGORIES, browse_node_id)
def get_immediate_subcategories(parent_id):
    config = load_config()
    if not all(config.get("amazon_uk", {}).values()):
        return []
    amazon = AmazonApi(config["amazon_uk"]["ACCESS_KEY"], config["amazon_uk"]["SECRET_KEY"],
                       config["amazon_uk"]["ASSOCIATE_TAG"], config["amazon_uk"]["COUNTRY"])
    try:
        browse_nodes = amazon.get_browse_nodes(browse_node_ids=[parent_id], resources=["BrowseNodes.Children"])
        if browse_nodes and browse_nodes.browse_nodes:
            return [{"id": node.browse_node_id, "name": node.display_name} for node in browse_nodes.browse_nodes[0].children]
        return []
    except Exception as e:
        print(f"Error fetching subcategories for {parent_id}: {str(e)}")
        return []
def filter_categories_with_products(category_ids, min_discount_percent):
    config = load_config()
    all_discounted_items = []
    for cat_id in category_ids:
        if all(config.get("amazon_uk", {}).values()):
            all_discounted_items.extend(search_amazon_uk_discounted(cat_id, min_discount_percent))
        if all(config.get("ebay_uk", {}).values()):
            all_discounted_items.extend(search_ebay_uk_discounted(cat_id, min_discount_percent))
        if config.get("awin", {}).get("API_TOKEN"):
            all_discounted_items.extend(search_awin_uk_discounted(cat_id, min_discount_percent))
        if all(config.get("cj", {}).values()):
            all_discounted_items.extend(search_cj_uk_discounted(cat_id, min_discount_percent))
    filtered_categories = []
    for cat_id in category_ids:
        if any(item for item in all_discounted_items if "BrowseNodeId" in item and item["BrowseNodeId"] == cat_id):
            category_title = get_amazon_category_title(cat_id) or cat_id
            filtered_categories.append({"id": cat_id, "name": category_title})
    return filtered_categories
def find_node(categories, target_id):
    for category in categories:
        if category['id'] == target_id:
            return category
        if 'subcategories' in category:
            result = find_node(category['subcategories'], target_id)
            if result is not None:
                return result
    return None
def find_pseudo_subcategories(parent_id, categories):
    node = find_node(categories, parent_id)
    if node and 'subcategories' in node:
        return [{'id': subcat['id'], 'name': subcat['name']} for subcat in node['subcategories']]
    return []
def load_users_settings():
    if os.path.exists(USERS_SETTINGS_FILE):
        try:
            with open(USERS_SETTINGS_FILE, 'r') as f:
                return json.load(f)
        except json.JSONDecodeError as e:
            raise Exception(f"Invalid JSON in {USERS_SETTINGS_FILE}: {str(e)}")
        except Exception as e:
            raise Exception(f"Error loading {USERS_SETTINGS_FILE}: {str(e)}")
    return {}
def save_users_settings(users_settings):
    try:
        with open(USERS_SETTINGS_FILE, 'w') as f:
            json.dump(users_settings, f, indent=4)
    except IOError as e:
        raise Exception(f"Failed to write to {USERS_SETTINGS_FILE}: {str(e)}")
    except Exception as e:
        raise Exception(f"Unexpected error saving {USERS_SETTINGS_FILE}: {str(e)}")
def get_user_settings(user_id):
    users_settings = load_users_settings()
    return users_settings.get(user_id, {})
def load_site_request(user_id):
    file_path = os.path.join(SITE_REQUEST_DIR, user_id)
    logger.debug(f"Attempting to load site request for user {user_id} from {file_path}")
    if os.path.exists(file_path):
        logger.debug(f"File exists: {file_path}")
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
                logger.debug(f"Successfully loaded data for user {user_id}: {json.dumps(data, indent=2)}")
                return data
        except json.JSONDecodeError as e:
            logger.error(f"JSON decode error for user {user_id} at {file_path}: {str(e)}")
            return {}
        except IOError as e:
            logger.error(f"IO error loading file for user {user_id} at {file_path}: {str(e)}")
            return {}
    else:
        logger.debug(f"No file found for user {user_id} at {file_path}")
        return {}
def save_site_request(user_id, site_request_data):
    file_path = os.path.join(SITE_REQUEST_DIR, user_id)
    try:
        with open(file_path, 'w') as f:
            json.dump(site_request_data, f, indent=4)
    except IOError as e:
        raise Exception(f"Failed to save site request for user {user_id}: {str(e)}")
# endregion Helper Functions

# region Detailed Fetch
def get_amazon_uk_full_details(asins, category):
    config = load_config()
    if not all(config.get("amazon_uk", {}).values()):
        return []
    amazon = AmazonApi(config["amazon_uk"]["ACCESS_KEY"], config["amazon_uk"]["SECRET_KEY"],
                       config["amazon_uk"]["ASSOCIATE_TAG"], config["amazon_uk"]["COUNTRY"])
    full_item_data = []
    try:
        item_response = amazon.get_items(
            item_ids=asins,
            resources=["ItemInfo.ByLineInfo", "ItemInfo.ContentInfo", "ItemInfo.Features", 
                       "ItemInfo.ProductInfo", "ItemInfo.Title", "Images.Primary.Large", 
                       "Offers.Listings.Price", "DetailPageURL"]
        )
        for item in item_response.items:
            current_price = item.offers.listings[0].price.amount if item.offers and item.offers.listings else None
            if item.offers and item.offers.listings and item.offers.listings[0].price.savings:
                savings = item.offers.listings[0].price.savings.amount
                original_price = current_price + savings
                discount_percent = float(item.offers.listings[0].price.savings.percentage)
            else:
                original_price = current_price
                discount_percent = 0.0
            item_data = {
                "source": "amazon_uk",
                "id": item.asin,
                "title": item.item_info.title.display_value if item.item_info.title else None,
                "product_url": item.detail_page_url,
                "current_price": current_price,
                "original_price": original_price,
                "discount_percent": discount_percent,
                "image_url": item.images.primary.large.url if item.images and item.images.primary else None,
                "category": category,
                "manufacturer": item.item_info.by_line_info.manufacturer.display_value if item.item_info.by_line_info and item.item_info.by_line_info.manufacturer else None,
                "dimensions": item.item_info.product_info.item_dimensions.display_value if item.item_info.product_info and item.item_info.product_info.item_dimensions else None,
                "features": item.item_info.features.display_values if item.item_info.features else []
            }
            full_item_data.append(item_data)
        time.sleep(1)
    except Exception as e:
        print(f"Amazon UK Error: {str(e)}")
    return full_item_data
def get_ebay_uk_full_details(item_ids, category):
    config = load_config()
    if not all(config.get("ebay_uk", {}).values()):
        return []
    url = "https://api.ebay.com/buy/browse/v1/item"
    headers = {"Authorization": f"Bearer {config['ebay_uk']['APP_ID']}"}
    full_item_data = []
    for item_id in item_ids:
        try:
            params = {"item_id": item_id}
            response = requests.get(url, headers=headers, params=params)
            item = response.json()
            current_price = float(item["price"]["value"])
            original_price_value = item.get("originalPrice", {}).get("value", current_price)
            original_price = float(original_price_value)
            discount = ((original_price - current_price) / original_price) * 100 if original_price > current_price else 0.0
            item_data = {
                "source": "ebay_uk",
                "id": item["itemId"],
                "title": item["title"],
                "product_url": item["itemWebUrl"],
                "current_price": current_price,
                "original_price": original_price,
                "discount_percent": round(discount, 2),
                "image_url": item["image"]["imageUrl"] if "image" in item else None,
                "category": category,
                "manufacturer": item.get("brand", None),
                "features": item.get("shortDescription", "").split(". ") if item.get("shortDescription") else []
            }
            full_item_data.append(item_data)
            time.sleep(1)
        except Exception as e:
            print(f"eBay UK Error for {item_id}: {str(e)}")
    return full_item_data
def get_awin_uk_full_details(product_ids, category):
    config = load_config()
    if not config.get("awin", {}).get("API_TOKEN"):
        return []
    url = f"https://api.awin.com/publishers/{config['awin']['API_TOKEN']}/products"
    full_item_data = []
    for product_id in product_ids:
        try:
            params = {"productId": product_id, "region": "UK"}
            response = requests.get(url, params=params)
            product = response.json()["products"][0]
            current_price = float(product["price"]["amount"])
            original_price = float(product.get("originalPrice", current_price))
            discount = ((original_price - current_price) / original_price) * 100 if original_price > current_price else 0.0
            item_data = {
                "source": "awin_uk",
                "id": product["productId"],
                "title": product["name"],
                "product_url": product["url"],
                "current_price": current_price,
                "original_price": original_price,
                "discount_percent": round(discount, 2),
                "image_url": product.get("imageUrl", None),
                "category": category,
                "manufacturer": product.get("brand", None),
                "dimensions": product.get("dimensions", None),
                "features": product.get("description", "").split(". ") if product.get("description") else []
            }
            full_item_data.append(item_data)
            time.sleep(1)
        except Exception as e:
            print(f"Awin UK Error for {product_id}: {str(e)}")
    return full_item_data
def get_cj_uk_full_details(skus, category):
    config = load_config()
    if not all(config.get("cj", {}).values()):
        return []
    url = "https://product-search.api.cj.com/v2/product-search"
    headers = {"Authorization": f"Bearer {config['cj']['API_KEY']}"}
    full_item_data = []
    for sku in skus:
        try:
            params = {"website-id": config["cj"]["WEBSITE_ID"], "sku": sku, "country": "UK"}
            response = requests.get(url, headers=headers, params=params)
            product = response.json()["products"][0]
            current_price = float(product["price"])
            original_price = float(product.get("salePrice", current_price))
            discount = ((original_price - current_price) / original_price) * 100 if original_price > current_price else 0.0
            item_data = {
                "source": "cj_uk",
                "id": product["sku"],
                "title": product["name"],
                "product_url": product["buyUrl"],
                "current_price": current_price,
                "original_price": original_price,
                "discount_percent": round(discount, 2),
                "image_url": product.get("imageUrl", None),
                "category": category,
                "manufacturer": product.get("manufacturerName", None),
                "dimensions": product.get("dimensions", None),
                "features": product.get("description", "").split(". ") if product.get("description") else []
            }
            full_item_data.append(item_data)
            time.sleep(1)
        except Exception as e:
            print(f"CJ UK Error for {sku}: {str(e)}")
    return full_item_data
# endregion Detailed Fetch

# region Search
def search_amazon_uk_discounted(browse_node_id, min_discount_percent=20):
    config = load_config()
    if not all(config.get("amazon_uk", {}).values()):
        return []
    amazon = AmazonApi(config["amazon_uk"]["ACCESS_KEY"], config["amazon_uk"]["SECRET_KEY"],
                       config["amazon_uk"]["ASSOCIATE_TAG"], config["amazon_uk"]["COUNTRY"])
    asins = []
    category_title = get_amazon_category_title(browse_node_id)
    if not category_title:
        return []
    try:
        search_params = {"BrowseNodeId": browse_node_id, "ItemCount": 10, "Resources": ["Offers.Listings.Price", "Offers.Summaries.HighestPrice"]}
        for page in range(1, 11):
            search_params["ItemPage"] = page
            search_result = amazon.search_items(**search_params)
            if not search_result or not search_result.items:
                break
            for item in search_result.items:
                if (item.offers and item.offers.listings and item.offers.listings[0].price and 
                    item.offers.listings[0].price.savings and 
                    item.offers.listings[0].price.savings.percentage >= min_discount_percent):
                    asins.append(item.asin)
            time.sleep(1)
        return get_amazon_uk_full_details(asins, category=category_title)
    except Exception as e:
        print(f"Amazon UK Search Error: {str(e)}")
        return []
def search_ebay_uk_discounted(browse_node_id, min_discount_percent=20):
    config = load_config()
    if not all(config.get("ebay_uk", {}).values()):
        return []
    category_title = get_amazon_category_title(browse_node_id)
    if not category_title:
        return []
    url = "https://api.ebay.com/buy/browse/v1/item_summary/search"
    headers = {"Authorization": f"Bearer {config['ebay_uk']['APP_ID']}"}
    params = {"q": category_title, "filter": "condition:NEW,availability:UK", "limit": "10", "sort": "-price"}
    item_ids = []
    try:
        response = requests.get(url, headers=headers, params=params)
        data = response.json()
        for item in data.get("itemSummaries", []):
            current_price = float(item["price"]["value"])
            original_price = float(item.get("originalPrice", {}).get("value", current_price))
            if original_price > current_price:
                discount = ((original_price - current_price) / original_price) * 100
                if discount >= min_discount_percent:
                    item_ids.append(item["itemId"])
        return get_ebay_uk_full_details(item_ids, category=category_title)
    except Exception as e:
        print(f"eBay UK Search Error: {str(e)}")
        return []
def search_awin_uk_discounted(browse_node_id, min_discount_percent=20):
    config = load_config()
    if not config.get("awin", {}).get("API_TOKEN"):
        return []
    category_title = get_amazon_category_title(browse_node_id)
    if not category_title:
        return []
    url = f"https://api.awin.com/publishers/{config['awin']['API_TOKEN']}/products"
    params = {"region": "UK", "search": category_title, "discount": "true"}
    product_ids = []
    try:
        response = requests.get(url, params=params)
        data = response.json()
        for product in data.get("products", []):
            current_price = float(product["price"]["amount"])
            original_price = float(product.get("originalPrice", current_price))
            if original_price > current_price:
                discount = ((original_price - current_price) / original_price) * 100
                if discount >= min_discount_percent:
                    product_ids.append(product["productId"])
        return get_awin_uk_full_details(product_ids, category=category_title)
    except Exception as e:
        print(f"Awin UK Search Error: {str(e)}")
        return []
def search_cj_uk_discounted(browse_node_id, min_discount_percent=20):
    config = load_config()
    if not all(config.get("cj", {}).values()):
        return []
    category_title = get_amazon_category_title(browse_node_id)
    if not category_title:
        return []
    url = "https://product-search.api.cj.com/v2/product-search"
    headers = {"Authorization": f"Bearer {config['cj']['API_KEY']}"}
    params = {"website-id": config["cj"]["WEBSITE_ID"], "keywords": category_title, "country": "UK", "sale-price": "true"}
    skus = []
    try:
        response = requests.get(url, headers=headers, params=params)
        data = response.json()
        for product in data.get("products", []):
            current_price = float(product["price"])
            original_price = float(product.get("salePrice", current_price))
            if original_price > current_price:
                discount = ((original_price - current_price) / original_price) * 100
                if discount >= min_discount_percent:
                    skus.append(product["sku"])
        return get_cj_uk_full_details(skus, category=category_title)
    except Exception as e:
        print(f"CJ UK Search Error: {str(e)}")
        return []
def search_wix_discounted(browse_node_id, min_discount_percent=20):
    users_settings = load_users_settings()
    all_discounted_products = []
    category_title = get_amazon_category_title(browse_node_id)
    if not category_title:
        print(f"No category title found for browse_node_id {browse_node_id}")
        return []

    for user_id, settings in users_settings.items():
        wix_client_id = settings.get("wixClientId")
        if not wix_client_id:
            print(f"No wixClientId found for user {user_id}")
            continue

        token_url = "https://www.wixapis.com/oauth2/token"
        payload = {"clientId": wix_client_id, "grantType": "anonymous"}
        headers = {"Content-Type": "application/json"}
        try:
            response = requests.post(token_url, json=payload, headers=headers)
            if response.status_code != 200:
                print(f"Error getting token for user {user_id}: {response.status_code} - {response.text}")
                continue
            token_data = response.json()
            access_token = token_data["access_token"]
            print(f"Access Token for user {user_id}: {access_token}")
        except Exception as e:
            print(f"Token fetch error for user {user_id}: {str(e)}")
            continue

        collections_url = "https://www.wixapis.com/stores-reader/v1/collections/query"
        headers = {"Content-Type": "application/json", "Authorization": f"Bearer {access_token}"}
def fetch_collections(limit=10, offset=0):
    query_payload = {"query": {"paging": {"limit": limit, "offset": offset}}, "includeNumberOfProducts": True}
            response = requests.post(collections_url, headers=headers, json=query_payload)
            if response.status_code != 200:
                print(f"Error fetching collections for user {user_id}: {response.status_code} - {response.text}")
                return None
            return response.json()

        products_url = "https://www.wixapis.com/stores/v1/products/query"
def fetch_products_for_collection(collection_id, limit=10, offset=0):
    filter_str = json.dumps({"collections.id": {"$hasSome": [collection_id]}})
            query_payload = {"query": {"filter": filter_str, "paging": {"limit": limit, "offset": offset}}}
            response = requests.post(products_url, headers=headers, json=query_payload)
            if response.status_code != 200:
                print(f"Error fetching products for collection {collection_id} for user {user_id}: {response.status_code} - {response.text}")
                return None
            return response.json()

        limit = 10
        offset = 0
        matching_collection = None

        while True:
            result = fetch_collections(limit=limit, offset=offset)
            if not result or "collections" not in result or not result["collections"]:
                break

            collections = result["collections"]
            for col in collections:
                if col["name"].lower() == category_title.lower() and not col["id"].startswith("00000000"):
                    matching_collection = col
                    break
            if matching_collection:
                break
            offset += limit
            if len(collections) < limit:
                break

        if not matching_collection:
            print(f"No matching collection found for category '{category_title}' for user {user_id}")
            continue

        collection_id = matching_collection["id"]
        offset = 0
        discounted_products = []

        while True:
            result = fetch_products_for_collection(collection_id, limit=limit, offset=offset)
            if not result or "products" not in result or not result["products"]:
                break

            products = result["products"]
            for product in products:
                current_price = float(product.get("price", {}).get("formatted", {}).get("price", "0").replace("$", "").replace("£", "").replace(",", "") or 0.0)
                original_price = float(product.get("discountedPrice", {}).get("formatted", {}).get("price", str(current_price)).replace("$", "").replace("£", "").replace(",", "") or current_price)
                if original_price > current_price:
                    discount = ((original_price - current_price) / original_price) * 100
                    if discount >= min_discount_percent:
                        base_url = product.get("productPageUrl", {}).get("base", "").rstrip("/") + "/" + product.get("productPageUrl", {}).get("path", "").lstrip("/")
                        product_url = f"{base_url}?referer={user_id}"
                        discounted_products.append({
                            "source": user_id,
                            "id": product.get("id", ""),
                            "title": product.get("name", ""),
                            "product_url": product_url,
                            "current_price": current_price,
                            "original_price": original_price,
                            "discount_percent": round(discount, 2),
                            "image_url": product.get("media", {}).get("mainMedia", {}).get("thumbnail", {}).get("url", ""),
                            "qty": int(product.get("stock", {}).get("quantity", 0)) if product.get("stock", {}).get("trackQuantity", False) else -1,
                            "category": matching_collection["name"],
                            "user_id": user_id
                        })
            offset += limit
            if len(products) < limit:
                break

        all_discounted_products.extend(discounted_products)
        print(f"Found {len(discounted_products)} discounted products for user {user_id} in category '{category_title}'")
    return all_discounted_products
def search_amazon_uk_all(browse_node_id):
    config = load_config()
    if not all(config.get("amazon_uk", {}).values()):
        return []
    amazon = AmazonApi(config["amazon_uk"]["ACCESS_KEY"], config["amazon_uk"]["SECRET_KEY"],
                       config["amazon_uk"]["ASSOCIATE_TAG"], config["amazon_uk"]["COUNTRY"])
    asins = []
    category_title = get_amazon_category_title(browse_node_id)
    if not category_title:
        return []
    try:
        search_params = {"BrowseNodeId": browse_node_id, "ItemCount": 10, "Resources": ["ItemInfo.Title", "Offers.Listings.Price", "Images.Primary.Large", "DetailPageURL"]}
        for page in range(1, 11):
            search_params["ItemPage"] = page
            search_result = amazon.search_items(**search_params)
            if not search_result or not search_result.items:
                break
            for item in search_result.items:
                asins.append(item.asin)
            time.sleep(1)
        return get_amazon_uk_full_details(asins, category=category_title)
    except Exception as e:
        print(f"Amazon UK Search Error: {str(e)}")
        return []
def search_ebay_uk_all(browse_node_id):
    config = load_config()
    if not all(config.get("ebay_uk", {}).values()):
        return []
    category_title = get_amazon_category_title(browse_node_id)
    if not category_title:
        return []
    url = "https://api.ebay.com/buy/browse/v1/item_summary/search"
    headers = {"Authorization": f"Bearer {config['ebay_uk']['APP_ID']}"}
    params = {"q": category_title, "filter": "condition:NEW,availability:UK", "limit": "10"}
    item_ids = []
    try:
        response = requests.get(url, headers=headers, params=params)
        data = response.json()
        for item in data.get("itemSummaries", []):
            item_ids.append(item["itemId"])
        return get_ebay_uk_full_details(item_ids, category=category_title)
    except Exception as e:
        print(f"eBay UK Search Error: {str(e)}")
        return []
def search_awin_uk_all(browse_node_id):
    config = load_config()
    if not config.get("awin", {}).get("API_TOKEN"):
        return []
    category_title = get_amazon_category_title(browse_node_id)
    if not category_title:
        return []
    url = f"https://api.awin.com/publishers/{config['awin']['API_TOKEN']}/products"
    params = {"region": "UK", "search": category_title}
    product_ids = []
    try:
        response = requests.get(url, params=params)
        data = response.json()
        for product in data.get("products", []):
            product_ids.append(product["productId"])
        return get_awin_uk_full_details(product_ids, category=category_title)
    except Exception as e:
        print(f"Awin UK Search Error: {str(e)}")
        return []
def search_cj_uk_all(browse_node_id):
    config = load_config()
    if not all(config.get("cj", {}).values()):
        return []
    category_title = get_amazon_category_title(browse_node_id)
    if not category_title:
        return []
    url = "https://product-search.api.cj.com/v2/product-search"
    headers = {"Authorization": f"Bearer {config['cj']['API_KEY']}"}
    params = {"website-id": config["cj"]["WEBSITE_ID"], "keywords": category_title, "country": "UK"}
    skus = []
    try:
        response = requests.get(url, headers=headers, params=params)
        data = response.json()
        for product in data.get("products", []):
            skus.append(product["sku"])
        return get_cj_uk_full_details(skus, category=category_title)
    except Exception as e:
        print(f"CJ UK Search Error: {str(e)}")
        return []
def search_wix_all(browse_node_id):
    users_settings = load_users_settings()
    all_products = []
    category_title = get_amazon_category_title(browse_node_id)
    if not category_title:
        print(f"No category title found for browse_node_id {browse_node_id}")
        return []

    for user_id, settings in users_settings.items():
        wix_client_id = settings.get("wixClientId")
        if not wix_client_id:
            print(f"No wixClientId found for user {user_id}")
            continue

        token_url = "https://www.wixapis.com/oauth2/token"
        payload = {"clientId": wix_client_id, "grantType": "anonymous"}
        headers = {"Content-Type": "application/json"}
        try:
            response = requests.post(token_url, json=payload, headers=headers)
            if response.status_code != 200:
                print(f"Error getting token for user {user_id}: {response.status_code} - {response.text}")
                continue
            token_data = response.json()
            access_token = token_data["access_token"]
            print(f"Access Token for user {user_id}: {access_token}")
        except Exception as e:
            print(f"Token fetch error for user {user_id}: {str(e)}")
            continue

        collections_url = "https://www.wixapis.com/stores-reader/v1/collections/query"
        headers = {"Content-Type": "application/json", "Authorization": f"Bearer {access_token}"}
def fetch_collections(limit=10, offset=0):
    query_payload = {"query": {"paging": {"limit": limit, "offset": offset}}, "includeNumberOfProducts": True}
            response = requests.post(collections_url, headers=headers, json=query_payload)
            if response.status_code != 200:
                print(f"Error fetching collections for user {user_id}: {response.status_code} - {response.text}")
                return None
            return response.json()

        products_url = "https://www.wixapis.com/stores/v1/products/query"
def fetch_products_for_collection(collection_id, limit=10, offset=0):
    filter_str = json.dumps({"collections.id": {"$hasSome": [collection_id]}})
            query_payload = {"query": {"filter": filter_str, "paging": {"limit": limit, "offset": offset}}}
            response = requests.post(products_url, headers=headers, json=query_payload)
            if response.status_code != 200:
                print(f"Error fetching products for collection {collection_id} for user {user_id}: {response.status_code} - {response.text}")
                return None
            return response.json()

        limit = 10
        offset = 0
        matching_collection = None

        while True:
            result = fetch_collections(limit=limit, offset=offset)
            if not result or "collections" not in result or not result["collections"]:
                break

            collections = result["collections"]
            for col in collections:
                if col["name"].lower() == category_title.lower() and not col["id"].startswith("00000000"):
                    matching_collection = col
                    break
            if matching_collection:
                break
            offset += limit
            if len(collections) < limit:
                break

        if not matching_collection:
            print(f"No matching collection found for category '{category_title}' for user {user_id}")
            continue

        collection_id = matching_collection["id"]
        offset = 0
        category_products = []

        while True:
            result = fetch_products_for_collection(collection_id, limit=limit, offset=offset)
            if not result or "products" not in result or not result["products"]:
                break

            products = result["products"]
            for product in products:
                current_price = float(product.get("price", {}).get("formatted", {}).get("price", "0").replace("$", "").replace("£", "").replace(",", "") or 0.0)
                original_price = float(product.get("discountedPrice", {}).get("formatted", {}).get("price", str(current_price)).replace("$", "").replace("£", "").replace(",", "") or current_price)
                discount = ((original_price - current_price) / original_price) * 100 if original_price > current_price else 0.0
                base_url = product.get("productPageUrl", {}).get("base", "").rstrip("/") + "/" + product.get("productPageUrl", {}).get("path", "").lstrip("/")
                product_url = f"{base_url}?referer={user_id}"
                category_products.append({
                    "source": user_id,
                    "id": product.get("id", ""),
                    "title": product.get("name", ""),
                    "product_url": product_url,
                    "current_price": current_price,
                    "original_price": original_price,
                    "discount_percent": round(discount, 2),
                    "image_url": product.get("media", {}).get("mainMedia", {}).get("thumbnail", {}).get("url", ""),
                    "qty": int(product.get("stock", {}).get("quantity", 0)) if product.get("stock", {}).get("trackQuantity", False) else -1,
                    "category": matching_collection["name"],
                    "user_id": user_id
                })
            offset += limit
            if len(products) < limit:
                break

        all_products.extend(category_products)
        print(f"Found {len(category_products)} products for user {user_id} in category '{category_title}'")
    return all_products
# endregion Search

# region Management Endpoints
@app.route('/users', methods=['GET'])
@require_permissions(["admin"], require_all=True)
def get_users():
    users_settings = load_users_settings()
    user_list = [{"USERid": user_id, "email_address": user["email_address"], "contact_name": user["contact_name"]} 
                 for user_id, user in users_settings.items()]
    return jsonify({"status": "success", "users": user_list}), 200

@app.route('/users/<user_id>', methods=['GET'])
@require_permissions(["admin"], require_all=True)
def get_user(user_id):
    users_settings = load_users_settings()
    if user_id not in users_settings:
        return jsonify({"status": "error", "message": "User not found"}), 404
    user = users_settings[user_id]
    user_data = {
        "USERid": user_id,
        "email_address": user["email_address"],
        "contact_name": user["contact_name"],
        "permissions": user["permissions"],
        "website_url": user.get("website_url", ""),
        "wixClientId": user.get("wixClientId", ""),
        "referrals": user.get("referrals", {"visits": [], "orders": []})
    }
    return jsonify({"status": "success", "user": user_data}), 200

@app.route('/permissions/<user_id>', methods=['GET'])
@require_permissions(["admin"], require_all=True)
def get_permissions(user_id):
    users_settings = load_users_settings()
    if user_id not in users_settings:
        return jsonify({"status": "error", "message": "User not found"}), 404
    permissions = users_settings[user_id]['permissions']
    return jsonify({"status": "success", "permissions": permissions}), 200

@app.route('/permissions/<user_id>', methods=['POST'])
@require_permissions(["admin"], require_all=True)
def add_permission(user_id):
    data = request.get_json()
    if 'permission' not in data:
        return jsonify({"status": "error", "message": "Permission field is required"}), 400
    permission = data['permission']
    users_settings = load_users_settings()
    if user_id not in users_settings:
        return jsonify({"status": "error", "message": "User not found"}), 404
    if permission in users_settings[user_id]['permissions']:
        return jsonify({"status": "error", "message": "Permission already exists"}), 400
    users_settings[user_id]['permissions'].append(permission)
    save_users_settings(users_settings)
    return jsonify({"status": "success", "message": "Permission added"}), 200

@app.route('/permissions/<user_id>', methods=['DELETE'])
@require_permissions(["admin"], require_all=True)
def remove_permission(user_id):
    data = request.get_json()
    if 'permission' not in data:
        return jsonify({"status": "error", "message": "Permission field is required"}), 400
    permission = data['permission']
    users_settings = load_users_settings()
    if user_id not in users_settings:
        return jsonify({"status": "error", "message": "User not found"}), 404
    if permission not in users_settings[user_id]['permissions']:
        return jsonify({"status": "error", "message": "Permission not found"}), 400
    users_settings[user_id]['permissions'].remove(permission)
    save_users_settings(users_settings)
    return jsonify({"status": "success", "message": "Permission removed"}), 200

@app.route('/config', methods=['GET'])
@require_permissions(["admin"], require_all=True)
def get_config():
    config = load_config()
    return jsonify({"status": "success", "count": len(config), "config": config})

@app.route('/config/<affiliate>', methods=['PATCH'])
@require_permissions(["admin"], require_all=True)
def replace_config(affiliate):
    config = load_config()
    data = request.get_json()
    if not data or not isinstance(data, dict):
        return jsonify({"status": "error", "message": "Request body must contain a dictionary of credentials"}), 400
    config[affiliate] = data
    save_config(config)
    return jsonify({"status": "success", "message": f"Credentials for {affiliate} replaced", "credentials": config[affiliate]})

@app.route('/<USERid>/user', methods=['GET'])
@require_permissions(["self", "admin"], require_all=False)
def get_user_settings_endpoint(USERid):
    try:
        settings = get_user_settings(USERid)
        return jsonify({
            "status": "success",
            "contact_name": settings.get("contact_name", ""),
            "website_url": settings.get("website_url", ""),
            "email_address": settings.get("email_address", ""),
            "phone_number": settings.get("phone_number", ""),
            "wixClientId": settings.get("wixClientId", "")
        })
    except Exception as e:
        print(f"Error in /<USERid>/user GET: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/<USERid>/user', methods=['PUT'])
@require_permissions(["self", "admin"], require_all=False)
def put_user_settings(USERid):
    if not request.json:
        return jsonify({"status": "error", "message": "Request body must contain settings"}), 400
    settings = request.json
    required_fields = ["contact_name", "website_url", "email_address", "phone_number", "wixClientId"]
    if not all(field in settings for field in required_fields):
        return jsonify({"status": "error", "message": "Settings must include all required fields"}), 400
    users_settings = load_users_settings()
    users_settings[USERid] = settings
    save_users_settings(users_settings)
    return jsonify({"status": "success", "message": f"Settings for user {USERid} replaced", "settings": settings})

@app.route('/<USERid>/user', methods=['PATCH'])
@require_permissions(["self", "admin", "wixpro"], require_all=False)
def patch_user_settings(USERid):
    if not request.json:
        return jsonify({"status": "error", "message": "Request body must contain settings"}), 400
    new_settings = request.json
    users_settings = load_users_settings()
    current_settings = users_settings.get(USERid, {})
    valid_fields = ["contact_name", "website_url", "email_address", "phone_number", "wixClientId"]
    if "wixpro" in request.permissions and not ("admin" in request.permissions or request.user_id == USERid):
        if any(key not in ["wixClientId"] for key in new_settings.keys()):
            return jsonify({"status": "error", "message": "Wixpro can only update wixClientId"}), 403
    for key in new_settings:
        if key in valid_fields:
            current_settings[key] = new_settings[key]
    users_settings[USERid] = current_settings
    save_users_settings(users_settings)
    return jsonify({"status": "success", "message": f"Settings for user {USERid} updated", "settings": current_settings})

@app.route('/<USERid>/mycategories', methods=['GET'])
@require_permissions(["self"], require_all=True)
def get_user_categories_endpoint(USERid):
    try:
        categories = get_user_categories(USERid)
        return jsonify({"status": "success", "count": len(categories), "categories": categories})
    except Exception as e:
        print(f"Error in /<USERid>/mycategories for USERid {USERid}: {str(e)}")
        return jsonify({"status": "error", "message": f"Failed to retrieve categories: {str(e)}"}), 500

@app.route('/<USERid>/mycategories', methods=['PUT'])
@require_permissions(["self"], require_all=True)
def put_user_categories(USERid):
    if not request.json or 'categories' not in request.json:
        return jsonify({"status": "error", "message": "Request body must contain 'categories' list"}), 400
    new_categories = request.json['categories']
    if not isinstance(new_categories, list):
        return jsonify({"status": "error", "message": "'categories' must be a list"}), 400
    users_data = load_users_categories()
    users_data[USERid] = new_categories
    save_users_categories(users_data)
    return jsonify({"status": "success", "message": f"Categories for user {USERid} replaced", "categories": new_categories})

@app.route('/<USERid>/mycategories', methods=['PATCH'])
@require_permissions(["self"], require_all=True)
def patch_user_categories(USERid):
    if not request.json or 'categories' not in request.json:
        return jsonify({"status": "error", "message": "Request body must contain 'categories' list"}), 400
    new_categories = request.json['categories']
    if not isinstance(new_categories, list):
        return jsonify({"status": "error", "message": "'categories' must be a list"}), 400
    users_data = load_users_categories()
    current_categories = set(users_data.get(USERid, []))
    current_categories.update(new_categories)
    users_data[USERid] = list(current_categories)
    save_users_categories(users_data)
    return jsonify({"status": "success", "message": f"Categories for user {USERid} patched", "categories": users_data[USERid]})

@app.route('/<USERid>/mycategories', methods=['DELETE'])
@require_permissions(["self"], require_all=True)
def delete_user_category(USERid):
    category_id = request.args.get('category_id')
    if not category_id:
        return jsonify({"status": "error", "message": "Query parameter 'category_id' is required"}), 400
    users_data = load_users_categories()
    if USERid in users_data and category_id in users_data[USERid]:
        users_data[USERid].remove(category_id)
        save_users_categories(users_data)
        return jsonify({"status": "success", "message": f"Category {category_id} removed for user {USERid}", "categories": users_data[USERid]})
    return jsonify({"status": "error", "message": f"Category {category_id} not found for user {USERid}"}), 404

@app.route('/categories', methods=['GET'])
@require_permissions(["allauth"], require_all=False)
def get_all_categories():
    config = load_config()
    parent_id = request.args.get('parent_id')
    amazon_config = config.get("amazon_uk", {})
    has_valid_amazon_config = all(amazon_config.get(field, "") for field in ["ACCESS_KEY", "SECRET_KEY", "ASSOCIATE_TAG", "COUNTRY"])
    if has_valid_amazon_config and parent_id:
        categories = get_immediate_subcategories(parent_id)
    elif not parent_id:
        categories = [{"id": cat["id"], "name": cat["name"]} for cat in PSEUDO_CATEGORIES]
    else:
        categories = find_pseudo_subcategories(parent_id, PSEUDO_CATEGORIES)
    return jsonify({"status": "success", "count": len(categories), "categories": categories})

@app.route('/<USERid>/products', methods=['GET'])
@require_permissions(["self"], require_all=True)
def get_user_product_list(USERid):
    products = get_user_products(USERid)
    return jsonify({"status": "success", "count": len(products), "products": products})

@app.route('/<USERid>/products/<product_id>', methods=['GET'])
@require_permissions(["self"], require_all=True)
def reduce_product_quantity(USERid, product_id):
    qty = request.args.get('qty', type=int)
    if qty is None or qty >= 0:
        return jsonify({"status": "error", "message": "Query parameter 'qty' must be a negative integer"}), 400
    users_products = load_users_products()
    if USERid not in users_products:
        return jsonify({"status": "error", "message": f"User {USERid} not found"}), 404
    current_products = users_products[USERid]
    product_to_update = next((p for p in current_products if p["id"] == product_id), None)
    if not product_to_update:
        return jsonify({"status": "error", "message": f"Product {product_id} not found for user {USERid}"}), 404
    current_qty = product_to_update["qty"]
    if current_qty != -1:
        product_to_update["qty"] = max(0, current_qty + qty)
    users_products[USERid] = current_products
    save_users_products(users_products)
    return jsonify({"status": "success", "message": f"Quantity reduced for product {product_id}", "product": product_to_update})

@app.route('/discounted-products', methods=['GET'])
def get_all_discounted_products():
    category_id = request.args.get('category_id')
    if not category_id:
        return jsonify({"status": "error", "message": "Query parameter 'category_id' is required"}), 400
    all_items = []
    config = load_config()
    search_categories = [category_id]
    for cat_id in search_categories:
        if all(config.get("amazon_uk", {}).values()):
            all_items.extend(search_amazon_uk_all(cat_id))
        if all(config.get("ebay_uk", {}).values()):
            all_items.extend(search_ebay_uk_all(cat_id))
        if config.get("awin", {}).get("API_TOKEN"):
            all_items.extend(search_awin_uk_all(cat_id))
        if all(config.get("cj", {}).values()):
            all_items.extend(search_cj_uk_all(cat_id))
        all_items.extend(search_wix_all(cat_id))
    return jsonify({"status": "success", "count": len(all_items), "products": all_items})

@app.route('/referal', methods=['POST'])
def handle_referral():
    try:
        data = request.get_json()
        if not data:
            return jsonify({"status": "error", "message": "No data provided"}), 400
        users_settings = load_users_settings()
        referer = data.get("referer", "none")
        timestamp = data.get("timestamp")
        if not timestamp:
            return jsonify({"status": "error", "message": "Timestamp is required"}), 400
        if referer not in users_settings:
            users_settings[referer] = {
                "contact_name": "",
                "website_url": "",
                "email_address": "",
                "phone_number": "",
                "wixClientId": "",
                "referrals": {"visits": [], "orders": []}
            }
        elif "referrals" not in users_settings[referer]:
            users_settings[referer]["referrals"] = {"visits": [], "orders": []}
        if "page" in data:
            referral_data = {"page": data["page"], "timestamp": timestamp}
            users_settings[referer]["referrals"]["visits"].append(referral_data)
            print(f"Stored page visit for referer {referer}: {referral_data}")
        elif "orderId" in data:
            referral_data = {"orderId": data["orderId"], "buyer": data["buyer"], "total": data["total"], "timestamp": timestamp}
            users_settings[referer]["referrals"]["orders"].append(referral_data)
            print(f"Stored order for referer {referer}: {referral_data}")
        else:
            return jsonify({"status": "error", "message": "Invalid referral data format"}), 400
        save_users_settings(users_settings)
        return jsonify({"status": "success", "message": "Referral data recorded", "referer": referer, "timestamp": timestamp})
    except Exception as e:
        print(f"Error in referral endpoint: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@app.route('/update-password', methods=['POST'])
@require_permissions(["allauth"], require_all=False)
def update_password():
    try:
        data = request.get_json()
        if not data:
            return jsonify({"status": "error", "message": "No data provided"}), 400
        email = data.get("email", "").strip()
        new_password = data.get("password", "").strip()
        if not email or not new_password:
            return jsonify({"status": "error", "message": "Email and password are required"}), 400
        users_settings = load_users_settings()
        matching_user_id = None
        for user_id, settings in users_settings.items():
            stored_email = settings.get("email_address", "").strip()
            if stored_email and stored_email.lower() == email.lower():
                matching_user_id = user_id
                break
        if not matching_user_id or matching_user_id != request.user_id:
            return jsonify({"status": "error", "message": f"Unauthorized: Can only update own password"}), 403
        hashed_password = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt())
        users_settings[matching_user_id]["password"] = hashed_password.decode('utf-8')
        save_users_settings(users_settings)
        return jsonify({"status": "success", "message": f"Password updated for user with email '{email}'", "user_id": matching_user_id}), 200
    except Exception as e:
        print(f"Error in update-password endpoint: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@app.route('/reset-password', methods=['POST'])
def reset_password():
    try:
        data = request.get_json()
        if not data:
            return jsonify({"status": "error", "message": "No data provided"}), 400
        email = data.get("email")
        if not email:
            return jsonify({"status": "error", "message": "Email is required"}), 400
        users_settings = load_users_settings()
        matching_user_id = None
        for user_id, settings in users_settings.items():
            if settings.get("email_address", "").lower() == email.lower():
                matching_user_id = user_id
                break
        if not matching_user_id:
            return jsonify({"status": "error", "message": "Email not found"}), 404
        user = users_settings[matching_user_id]
        phone_number = user.get("phone_number", "").strip()
        if not phone_number:
            return jsonify({"status": "error", "message": "No phone number associated with this account"}), 400
        otp = ''.join(random.choices(string.digits, k=6))
        reset_expiry = datetime.datetime.utcnow() + datetime.timedelta(minutes=15)
        if "reset_codes" not in app.config:
            app.config["reset_codes"] = {}
        app.config["reset_codes"][matching_user_id] = {"code": otp, "expires": reset_expiry.isoformat()}
        config = load_config()
        textmagic_config = config.get("textmagic", {})
        username = textmagic_config.get("USERNAME")
        api_key = textmagic_config.get("API_KEY")
        if not username or not api_key:
            return jsonify({"status": "error", "message": "TextMagic credentials not configured"}), 500
        url = "https://rest.textmagic.com/api/v2/messages"
        payload = {"text": f"clubmadiera.io sent you a one-time password: {otp}. It expires in 15mins.", "phones": phone_number}
        headers = {"X-TM-Username": username, "X-TM-Key": api_key, "Content-Type": "application/x-www-form-urlencoded"}
        response = requests.post(url, data=payload, headers=headers)
        if response.status_code == 201:
            return jsonify({"status": "success", "message": "A one-time password has been sent to your phone"}), 200
        else:
            return jsonify({"status": "error", "message": f"Failed to send SMS: {response.text}"}), 500
    except Exception as e:
        print(f"Error in reset-password endpoint: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@app.route('/verify-reset-code', methods=['POST'])
def verify_reset_code():
    try:
        data = request.get_json(silent=True)
        if not data or not isinstance(data, dict):
            return jsonify({"status": "error", "message": "Invalid or missing JSON data"}), 400
        email = data.get("email")
        code = data.get("code")
        new_password = data.get("new_password")
        if not all([email, code, new_password]):
            return jsonify({"status": "error", "message": "Email, code, and new password are required"}), 400
        users_settings = load_users_settings()
        matching_user_id = None
        for user_id, settings in users_settings.items():
            if settings.get("email_address", "").lower() == email.lower():
                matching_user_id = user_id
                break
        if not matching_user_id:
            return jsonify({"status": "error", "message": "Email not found"}), 404
        stored_reset = app.config.get("reset_codes", {}).get(matching_user_id, {})
        stored_code = stored_reset.get("code")
        if not stored_code:
            return jsonify({"status": "error", "message": "No reset code found for this user"}), 400
        try:
            expiry = datetime.datetime.fromisoformat(stored_reset.get("expires", "2000-01-01T00:00:00"))
        except (ValueError, TypeError) as e:
            print(f"Error parsing expiry: {str(e)}")
            return jsonify({"status": "error", "message": "Invalid reset code expiry format"}), 500
        if stored_code != code or datetime.datetime.utcnow() > expiry:
            return jsonify({"status": "error", "message": "Invalid or expired reset code"}), 400
        hashed_password = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        users_settings[matching_user_id]["password"] = hashed_password
        save_users_settings(users_settings)
        if matching_user_id in app.config.get("reset_codes", {}):
            del app.config["reset_codes"][matching_user_id]
        return jsonify({"status": "success", "message": "Password updated successfully"}), 200
    except Exception as e:
        print(f"Unexpected error in verify-reset-code endpoint: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@app.route('/<USERid>/visits', methods=['GET'])
@require_permissions(["self", "admin"], require_all=False)
def get_user_visits(USERid):
    try:
        users_settings = load_users_settings()
        if USERid not in users_settings:
            return jsonify({"status": "error", "message": f"User {USERid} not found"}), 404
        referrals = users_settings[USERid].get("referrals", {})
        visits = referrals.get("visits", [])
        return jsonify({"status": "success", "count": len(visits), "visits": visits})
    except Exception as e:
        print(f"Error in /<USERid>/visits GET: {str(e)}")
        return jsonify({"status": "error", "message": f"Failed to retrieve visits: {str(e)}"}), 500

@app.route('/<USERid>/orders', methods=['GET'])
@require_permissions(["self", "admin"], require_all=False)
def get_user_orders(USERid):
    try:
        users_settings = load_users_settings()
        if USERid not in users_settings:
            return jsonify({"status": "error", "message": f"User {USERid} not found"}), 404
        referrals = users_settings[USERid].get("referrals", {})
        orders = referrals.get("orders", [])
        return jsonify({"status": "success", "count": len(orders), "orders": orders})
    except Exception as e:
        print(f"Error in /<USERid>/orders GET: {str(e)}")
        return jsonify({"status": "error", "message": f"Failed to retrieve orders: {str(e)}"}), 500
# endregion Management Endpoints

# region Logged in Endpoints
@app.route('/admin', methods=['GET'])
@require_permissions(["admin"], require_all=True)
def admin():
    return render_template('admin.html')

@app.route('/community', methods=['GET'])
@require_permissions(["community", "admin"], require_all=False)
def community():
    return render_template('community.html')

@app.route('/merchant', methods=['GET'])
@require_permissions(["merchant", "admin"], require_all=False)
def merchant():
    return render_template('merchant.html')

@app.route('/partner', methods=['GET'])
@require_permissions(["wixpro", "admin"], require_all=False)
def wixpro():
    return render_template('partner.html')

@app.route('/<user_id>/siterequest', methods=['POST'])
@require_permissions(["admin", "merchant", "community"], require_all=False)
def save_site_request_endpoint(user_id):
    try:
        data = request.get_json()
        if not data:
            return jsonify({"status": "error", "message": "No data provided"}), 400
        body_user_id = data.get("userId")
        if body_user_id and body_user_id != user_id:
            return jsonify({"status": "error", "message": "User ID in body does not match URL"}), 400
        if not user_id or request.user_id != user_id:
            return jsonify({"status": "error", "message": "Unauthorized: Must match user_id"}), 403
        request_type = data.get("type", "community")
        site_request = {
            "user_id": user_id,
            "type": request_type,
            "communityName": data.get("communityName") or data.get("storeName") or "",
            "aboutCommunity": data.get("aboutCommunity") or data.get("aboutStore") or "",
            "communityLogos": data.get("communityLogos") or data.get("storeLogos") or [],
            "colorPrefs": data.get("colorPrefs", ""),
            "stylingDetails": data.get("stylingDetails", ""),
            "preferredDomain": data.get("preferredDomain", "mycommunity.org"),
            "emails": data.get("emails", []),
            "pages": data.get("pages", []),
            "widgets": data.get("widgets", []),
            "submitted_at": datetime.datetime.utcnow().isoformat()
        }
        if not site_request["communityName"]:
            return jsonify({"status": "error", "message": "Community name or store name is required"}), 400
        domain_regex = r'^[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$'
        if not re.match(domain_regex, site_request["preferredDomain"]):
            return jsonify({"status": "error", "message": "Invalid domain name"}), 400
        for page in site_request["pages"]:
            if "images" in page and page["images"]:
                page["images"] = [img if isinstance(img, str) else "placeholder" for img in page["images"]]
        save_site_request(user_id, site_request)
        return jsonify({"status": "success", "message": "Site request saved successfully"}), 200
    except Exception as e:
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

# ... (Previous code remains unchanged up to the end of the last section) ...

@app.route('/siterequests', methods=['GET'])
@require_permissions(["admin", "wixpro"], require_all=False)
def list_site_requests():
    try:
        siterequest_dir = 'siterequest'
        logger.debug(f"Looking in directory: {os.path.abspath(siterequest_dir)}")
        if not os.path.exists(siterequest_dir):
            logger.debug("Directory does not exist")
            return jsonify({"status": "success", "siterequests": []}), 200
        users_settings = load_users_settings()
        siterequests = []
        files = os.listdir(siterequest_dir)
        logger.debug(f"Found files: {files}")
        for filename in files:
            user_id = filename.replace('.json', '')
            logger.debug(f"Processing user_id: {user_id}")
            site_request = load_site_request(user_id)
            if not site_request:
                logger.debug(f"No data loaded for {user_id}")
                continue
            contact_name = users_settings.get(user_id, {}).get('contact_name', '')
            email = users_settings.get(user_id, {}).get('email_address', '')
            request_type = site_request.get('type', '')
            store_name = site_request.get('storeName')
            community_name = site_request.get('communityName')
            organisation = store_name if store_name else community_name if community_name else ''
            received_at = site_request.get('submitted_at', '')
            siterequests.append({
                'user_id': user_id,
                'type': request_type,
                'received_at': received_at,
                'contact_name': contact_name,
                'email': email,
                'organisation': organisation
            })
            logger.debug(f"Added request for {user_id}")
        logger.debug(f"Total requests found: {len(siterequests)}")
        siterequests.sort(key=lambda x: x['received_at'] or '', reverse=True)
        return jsonify({"status": "success", "siterequests": siterequests}), 200
    except Exception as e:
        logger.error(f"Error in list_site_requests: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error: {str(e)}"}), 500

@app.route('/render-md/<path:full_path>', methods=['GET'])
@require_permissions(["allauth"], require_all=False)
def render_md(full_path):
    """
    Render Markdown files from the static folder or GitHub based on the URL path.
    Returns an HTML response using templates from static/error/<status_code>.md.
    """
    try:
        # Parse the full_path, removing trailing slashes
        segments = full_path.rstrip('/').split('/')
        if not segments or segments == ['']:
            raise ValueError("Invalid path provided")

        # Determine source: static folder or GitHub
        if segments[0] == 'static':
            # Handle static file
            if len(segments) < 2:
                raise ValueError("No file path provided after 'static'")
            file_path = '/'.join(segments[1:])
            if not file_path.endswith('.md'):
                raise ValueError("Only .md files are supported")
            static_file = os.path.join(app.static_folder, file_path)
            if not os.path.isfile(static_file):
                raise FileNotFoundError("File not found in static folder")
            with open(static_file, 'r', encoding='utf-8') as f:
                md_content = f.read()
        else:
            # Handle GitHub file
            if len(segments) < 4:
                raise ValueError("Invalid GitHub path: Must provide owner/repo/branch/path")
            owner, repo, branch, *path_segments = segments
            path = '/'.join(path_segments)
            if not path.endswith('.md'):
                raise ValueError("Only .md files are supported")
            url = f"https://raw.githubusercontent.com/{owner}/{repo}/{branch}/{path}"
            response = requests.get(url)
            if response.status_code != 200:
                raise FileNotFoundError("File not found on GitHub")
            md_content = response.text

        # Convert Markdown to HTML with table support
        html_content = markdown.markdown(md_content, extensions=['tables'])
        status_code = 200

    except ValueError as e:
        # Invalid paths or file types result in 404
        status_code = 404
        error_message = str(e)
    except FileNotFoundError as e:
        # File not found results in 404
        status_code = 404
        error_message = str(e)
    except requests.RequestException as e:
        # Network issues with GitHub result in 500
        status_code = 500
        error_message = "Failed to fetch from GitHub"
    except Exception as e:
        # Unexpected errors result in 500
        status_code = 500
        error_message = "An unexpected error occurred"
        logger.error(f"Error: {e}", exc_info=True)

    # Load the corresponding template
    template_path = os.path.join(app.static_folder, 'error', f'{status_code}.md')
    with open(template_path, 'r', encoding='utf-8') as f:
        template = f.read()

    # Replace the appropriate placeholder
    if status_code == 200:
        final_html = template.replace('{content}', html_content)
    else:
        final_html = template.replace('{error_message}', error_message)

    # Create and return the response
    response = make_response(final_html, status_code)
    response.headers['Content-Type'] = 'text/html'
    return response

@app.route('/check-domain', methods=['GET'])
@require_permissions(["allauth"], require_all=False)  # Custom decorator applied
def check_domain():
    # Get domain from query parameter
    domain = request.args.get('domain')
    
    # Basic validation (matches client-side regex: /^[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$/)
    if not domain:
        return jsonify({"error": "Please provide a domain name"}), 400
    
    if not all(c.isalnum() or c in '-.' for c in domain) or \
       not '.' in domain or \
       len(domain.split('.')[-1]) < 2:
        return jsonify({"error": "Invalid domain name (e.g., mystore.uk)"}), 400
    
    # Query WHOIS data using python-whois
    try:
        w = whois.whois(domain)
        # If no registration data exists (e.g., creation_date is None), domain is available
        is_available = w.creation_date is None
        return jsonify({
            "domain": domain,
            "available": is_available
        }), 200
    except Exception as e:
        # Handle WHOIS query failures (e.g., timeouts, invalid TLDs)
        return jsonify({"error": f"Failed to check domain availability: {str(e)}"}), 500

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
    
# endregion Logged in Endpoints

# region Public Endpoints
@app.route('/', methods=['GET'])
def home():
    return render_template('login.html')

@app.route('/branding', methods=['GET'])
def branding():
    try:
        root_dir = os.path.dirname(os.path.abspath(__file__))
        json_path = os.path.join(root_dir, 'branding.json')
        with open(json_path, 'r') as f:
            branding_data = json.load(f)
        return jsonify(branding_data)
    except FileNotFoundError:
        return jsonify({'content': '<h1>Branding content not found</h1>'}), 500
    except Exception as e:
        return jsonify({'content': f'Internal Server Error: {str(e)}'}), 500

@app.route('/login', methods=['POST'])
def login():
    """
    Authenticate a user and return a JWT token with their permissions.
    Expects JSON payload with 'email' and 'password'.
    Returns user details, token, and redirect URL based on permissions.
    """
    try:
        # Parse incoming JSON data
        data = request.get_json(silent=True)
        if not data or not isinstance(data, dict):
            return jsonify({"status": "error", "message": "Invalid or missing JSON data"}), 400

        # Extract and validate required fields
        email = data.get("email", "").strip().lower()
        password = data.get("password", "").strip()
        if not email or not password:
            return jsonify({"status": "error", "message": "Email and password are required"}), 400

        # Load user settings
        users_settings = load_users_settings()
        if not users_settings:
            return jsonify({"status": "error", "message": "No users registered in the system"}), 500

        # Find user by email and verify password
        matching_user_id = None
        for user_id, settings in users_settings.items():
            stored_email = settings.get("email_address", "").strip().lower()
            stored_password = settings.get("password", "")
            if stored_email == email:
                # Ensure stored password is bytes for bcrypt
                if isinstance(stored_password, str):
                    stored_password = stored_password.encode('utf-8')
                if bcrypt.checkpw(password.encode('utf-8'), stored_password):
                    matching_user_id = user_id
                    break

        # Check if authentication succeeded
        if not matching_user_id:
            return jsonify({"status": "error", "message": "Invalid email or password"}), 401

        # Get user permissions and details
        user_data = users_settings[matching_user_id]
        permissions = user_data.get("permissions", [])
        contact_name = user_data.get("contact_name", "User")

        # Determine redirect URL based on highest-priority permission
        redirect_url = None
        if "admin" in permissions:
            redirect_url = url_for('admin')
        elif "merchant" in permissions:
            redirect_url = url_for('merchant')
        elif "community" in permissions:
            redirect_url = url_for('community')
        elif "wixpro" in permissions:
            redirect_url = url_for('wixpro')

        # Generate JWT token
        token_payload = {
            "userId": matching_user_id,
            "permissions": permissions,
            "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=1),  # Token expires in 1 hour
            "iat": datetime.datetime.utcnow()  # Issued at time
        }
        token = jwt.encode(token_payload, app.config['JWT_SECRET_KEY'], algorithm="HS256")

        # Prepare response
        response_data = {
            "status": "success",
            "message": "Login successful",
            "token": token,
            "userId": matching_user_id,
            "contact_name": contact_name
        }
        if redirect_url:
            response_data["redirect_url"] = redirect_url

        return jsonify(response_data), 200

    except Exception as e:
        # Log the error for debugging (assuming logging is set up)
        logger.error(f"Login error: {str(e)}")
        return jsonify({"status": "error", "message": f"Server error during login: {str(e)}"}), 500

@app.route('/signup', methods=['GET'])
def signup_page():
    return render_template('signup.html')

@app.route('/signup', methods=['POST'])
def signup():
    data = request.get_json()
    required_fields = ['signup_type', 'contact_name', 'signup_email', 'signup_password']
    if not all(field in data for field in required_fields):
        return jsonify({"status": "error", "message": "All fields are required"}), 400
    users_settings = load_users_settings()
    if any(user['email_address'] == data['signup_email'] for user in users_settings.values()):
        return jsonify({"status": "error", "message": "Email already exists"}), 400
    while True:
        USERid = generate_code()
        if USERid not in users_settings:
            break
    hashed_password = bcrypt.hashpw(data['signup_password'].encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
    users_settings[USERid] = {
        "email_address": data['signup_email'],
        "password": hashed_password,
        "contact_name": data['contact_name'],
        "permissions": [data['signup_type']],
        "user_categories": [data['signup_type']],
        "website_url": "",
        "wixClientId": "",
        "referrals": {"visits": [], "orders": []}
    }
    save_users_settings(users_settings)
    return jsonify({"status": "success", "message": "Signup successful"}), 201
# endregion Public Endpoints

# region Velocify Public Endpoints
@app.route('/<USERid>/discounted-products', methods=['GET'])
def get_user_discounted_products(USERid):
    category_id = request.args.get('category_id')
    min_discount = request.args.get('min_discount', default=20, type=int)
    root_category_ids = get_user_categories(USERid)
    all_discounted_items = []
    config = load_config()
    search_categories = [category_id] if category_id else root_category_ids
    for cat_id in search_categories:
        if all(config.get("amazon_uk", {}).values()):
            all_discounted_items.extend(search_amazon_uk_discounted(cat_id, min_discount))
        if all(config.get("ebay_uk", {}).values()):
            all_discounted_items.extend(search_ebay_uk_discounted(cat_id, min_discount))
        if config.get("awin", {}).get("API_TOKEN"):
            all_discounted_items.extend(search_awin_uk_discounted(cat_id, min_discount))
        if all(config.get("cj", {}).values()):
            all_discounted_items.extend(search_cj_uk_discounted(cat_id, min_discount))
        all_discounted_items.extend(search_wix_discounted(cat_id, min_discount))
    return jsonify({"status": "success", "count": len(all_discounted_items), "products": all_discounted_items, "min_discount": min_discount})

@app.route('/<USERid>/categories', methods=['GET'])
def get_categories(USERid):
    parent_id = request.args.get('parent_id')
    min_discount = request.args.get('min_discount', default=20, type=int)
    all_categories = []
    root_category_ids = get_user_categories(USERid)
    try:
        if parent_id:
            subcategories = get_immediate_subcategories(parent_id)
            if subcategories:
                subcategory_ids = [cat["id"] for cat in subcategories]
                all_categories = filter_categories_with_products(subcategory_ids, min_discount)
        else:
            all_categories = filter_categories_with_products(root_category_ids, min_discount)
        return jsonify({"status": "success", "count": len(all_categories), "categories": all_categories, "min_discount": min_discount}) if all_categories else \
               jsonify({"status": "success", "count": 0, "categories": [], "message": f"No categories with products at {min_discount}% discount found."})
    except Exception as e:
        return jsonify({"status": "error", "message": f"Error fetching categories: {str(e)}"}), 500
# endregion Velocify Public Endpoints

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)

+-utils/auth.py
def login_required(required_permissions, require_all=True):
    
def decorator(f):
    @wraps(f)
def decorated_function(*args, **kwargs):
    token = request.headers.get("Authorization", "").replace("Bearer ", "")
            if not token:
                return jsonify({"status": "error", "message": "Token required"}), 401
            try:
                payload = jwt.decode(token, current_app.config['JWT_SECRET_KEY'], algorithms=["HS256"])
                if datetime.datetime.utcnow().timestamp() > payload["exp"]:
                    return jsonify({"status": "error", "message": "Token expired"}), 401
                request.user_id = payload["userId"]
                request.permissions = payload.get("permissions", [])
                effective_perms = []
                for perm in required_permissions:
                    if perm == "allauth":
                        effective_perms.extend(["admin", "merchant", "community", "wixpro"])
                    elif perm == "self":
                        user_id = next((v for v in kwargs.values() if isinstance(v, str)), None)
                        if user_id and request.user_id != user_id:
                            effective_perms.append(None)
                        else:
                            effective_perms.append("self")
                    else:
                        effective_perms.append(perm)
                if require_all:
                    if not all(p in request.permissions for p in effective_perms if p and p != "self"):
                        return jsonify({"status": "error", "message": f"Insufficient permissions: {effective_perms}"}), 403
                else:
                    if not any(p in request.permissions for p in effective_perms if p and p != "self"):
                        return jsonify({"status": "error", "message": f"Insufficient permissions: {effective_perms}"}), 403
                return f(*args, **kwargs)
            except jwt.InvalidTokenError:
                return jsonify({"status": "error", "message": "Invalid token"}), 401
            except Exception as e:
                return jsonify({"status": "error", "message": f"Token error: {str(e)}"}), 500
        return decorated_function
    return decorator
def login_user():
    data = request.get_json()
    if not data or 'email' not in data or 'password' not in data:
        return jsonify({"status": "error", "message": "Email and password required"}), 400
    email = data["email"].strip().lower()
    password = data["password"].strip()
    users_settings = load_users_settings()
    user_id = None
    for uid, settings in users_settings.items():
        if settings.get("email_address", "").lower() == email and bcrypt.checkpw(password.encode('utf-8'), settings["password"].encode('utf-8')):
            user_id = uid
            break
    if not user_id:
        return jsonify({"status": "error", "message": "Invalid credentials"}), 401
    permissions = users_settings[user_id].get("permissions", [])
    token = jwt.encode(
        {"userId": user_id, "permissions": permissions, "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=1)},
        current_app.config['JWT_SECRET_KEY'],
        algorithm="HS256"
    )
    
    # Determine redirect URL based on permissions
    redirect_url = None
    if "admin" in permissions:
        redirect_url = url_for('admin')  # Assuming an admin route exists
    elif "merchant" in permissions:
        redirect_url = url_for('merchant')  # Assuming a merchant route exists
    elif "community" in permissions:
        redirect_url = url_for('community')  # Assuming a community route exists
    elif "wixpro" in permissions:
        redirect_url = url_for('wixpro')  # Assuming a wixpro route exists
    else:
        redirect_url = url_for('home')  # Default fallback

    response_data = {
        "status": "success",
        "token": token,
        "userId": user_id,
        "redirect_url": redirect_url  # Add redirect URL to response
    }
    return jsonify(response_data), 200
def signup_user():
    data = request.get_json()
    # Base required fields
    required_fields = ['signup_type', 'contact_name', 'signup_email', 'signup_password']
    if not all(k in data for k in required_fields):
        return jsonify({"status": "error", "message": "Signup type, contact name, email, and password are required"}), 400

    # Phone number is required for community and merchant, optional for wixpro
    signup_type = data['signup_type']
    signup_phone = data.get('signup_phone')
    if signup_type in ['community', 'seller'] and (signup_phone is None or signup_phone == ''):
        return jsonify({"status": "error", "message": "Phone number is required for Community Group and Merchant signups"}), 400

    # Validate phone number format if provided
    if signup_phone:
        import re
        if not re.match(r'^\d{10}$', signup_phone):
            return jsonify({"status": "error", "message": "Phone number must be a 10-digit number with no spaces or special characters"}), 400

    users_settings = load_users_settings()
    if any(u['email_address'] == data['signup_email'] for u in users_settings.values()):
        return jsonify({"status": "error", "message": "Email exists"}), 400

    USERid = generate_code()
    hashed_password = bcrypt.hashpw(data['signup_password'].encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
    users_settings[USERid] = {
        "email_address": data['signup_email'],
        "password": hashed_password,
        "contact_name": data['contact_name'],
        "phone_number": signup_phone,  # Store the phone number
        "permissions": [data['signup_type']]
    }
    save_users_settings(users_settings)
    return jsonify({"status": "success", "message": "Signup successful"}), 201
def generate_token(user_id, permissions):
    """Generate a JWT token with user_id and permissions."""
    payload = {
        "userId": user_id,  # Match login_user key
        "permissions": permissions,
        "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=24)  # 24-hour expiry
    }
    return jwt.encode(payload, current_app.config['JWT_SECRET_KEY'], algorithm='HS256')

+-utils/categories.py
def get_all_categories(parent_id=None):
    config = load_config() 
    if parent_id and all(config.get("amazon_uk", {}).values()): 
        amazon = AmazonApi(config["amazon_uk"]["ACCESS_KEY"], config["amazon_uk"]["SECRET_KEY"], config["amazon_uk"]["ASSOCIATE_TAG"], config["amazon_uk"]["COUNTRY"]) 
        browse_nodes = amazon.get_browse_nodes(browse_node_ids=[parent_id], resources=["BrowseNodes.Children"]) 
        return [{"id": node.browse_node_id, "name": node.display_name} for node in browse_nodes.browse_nodes[0].children] 
    return [{"id": cat["id"], "name": cat["name"]} for cat in PSEUDO_CATEGORIES]
def filter_categories_with_products(category_ids, min_discount_percent):
    # Placeholder for filtering logic 
    return [{"id": cat_id, "name": cat_id} for cat_id in category_ids]

+-utils/config.py
def load_config():
    
def save_config(config):
    with open(CONFIG_FILE, 'w') as f: 
        json.dump(config, f, indent=4)

+-utils/data.py
def load_site_request(user_id):
    file_path = os.path.join(SITE_REQUEST_DIR, user_id) 
    if os.path.exists(file_path): 
        with open(file_path, 'r') as f: 
            return json.load(f) 
    return {}
def save_site_request(user_id, site_request_data):
    if not os.path.exists(SITE_REQUEST_DIR): 
        os.makedirs(SITE_REQUEST_DIR) 
    file_path = os.path.join(SITE_REQUEST_DIR, user_id) 
    with open(file_path, 'w') as f: 
        json.dump(site_request_data, f, indent=4)

+-utils/products.py
def search_all_discounted(category_id):
    config = load_config() 
    items = [] 
    if all(config.get("amazon_uk", {}).values()): 
        amazon = AmazonApi(config["amazon_uk"]["ACCESS_KEY"], config["amazon_uk"]["SECRET_KEY"], config["amazon_uk"]["ASSOCIATE_TAG"], config["amazon_uk"]["COUNTRY"]) 
        search_result = amazon.search_items(BrowseNodeId=category_id, ItemCount=10) 
        items.extend([{"id": item.asin, "title": item.item_info.title.display_value} for item in search_result.items]) 
    return items

+-utils/users.py
def load_users_settings():
    if os.path.exists(USERS_SETTINGS_FILE):
        with open(USERS_SETTINGS_FILE, 'r') as f:
            users_settings = json.load(f)
            # Ensure all user records have a phone_number field
            for user_id, settings in users_settings.items():
                if 'phone_number' not in settings:
                    settings['phone_number'] = None  # Set to None for existing users
            return users_settings
    return {}
def save_users_settings(users_settings):
    with open(USERS_SETTINGS_FILE, 'w') as f:
        json.dump(users_settings, f, indent=4)
def get_user_settings(user_id):
    user_settings = load_users_settings().get(user_id, {})
    # Ensure the returned settings include phone_number
    if 'phone_number' not in user_settings:
        user_settings['phone_number'] = None
    return user_settings
def generate_code():
    charset = string.digits + string.ascii_uppercase
    code = ''.join(random.choice(charset) for _ in range(7))
    total = sum(charset.index(c) for c in code)
    checksum = charset[total % 36]
    return code + checksum

